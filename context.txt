// ===== Directory: . =====

// .gitignore
node_modules
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/packages/test'],
  moduleNameMapper: {
    '^@core/(.*)$': '<rootDir>/packages/core/src/$1',
    '^@infrastructure/(.*)$': '<rootDir>/packages/infrastructure/src/$1',
  },
};// package.json
{
  "name": "test-medical-appointments",
  "version": "1.0.0",
  "private": true,
  "description": "Backend for Medical Appointment Scheduling",
  "scripts": {
    "context": "node scripts/generate-context.js",
    "build": "tsc --build",
    "test": "jest",
    "test:watch": "jest --watch",
    "deploy:api": "cd services/appointment-api && sls deploy --verbose",
    "deploy:processor": "cd services/appointment-processor && sls deploy --verbose",
    "offline:api": "cd services/appointment-api && sls offline start",
    "lint": "eslint . --ext .ts"
  },
  "devDependencies": {
    "@types/jest": "^30.0.0",
    "@types/node": "^24.3.0",
    "esbuild": "^0.25.9",
    "eslint": "^9.33.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "jest": "^30.0.5",
    "prettier": "^3.6.2",
    "serverless": "^4.18.0",
    "serverless-dynamodb-local": "^0.2.40",
    "serverless-esbuild": "^1.55.1",
    "serverless-offline": "^14.4.0",
    "serverless-offline-sns": "^0.78.1",
    "serverless-offline-sqs": "^8.0.0",
    "ts-jest": "^29.4.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.2",
    "zod": "^4.0.17"
  },
  "pnpm": {
    "approvedBuildScripts": [
      "esbuild",
      "serverless"
    ]
  }
}

// ===== Directory: packages/core =====

// package.json
{
  "name": "@core",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "dependencies": {
    "zod": "^4.0.17"
  }
}

// ===== Directory: packages/core/src/application/dtos =====

// AppointmentDtos.ts
import { z } from 'zod';
import { AppointmentSchema } from '../../domain/entities/Appointment';

export const CreateAppointmentSchema = z.object({
  insuredId: z.string().regex(/^[0-9]{5}$/, "El insuredId debe ser de 5 dígitos numéricos."),
  scheduleId: z.number().int().positive(),
  countryISO: z.enum(['PE', 'CL']),
});
export type CreateAppointmentDto = z.infer<typeof CreateAppointmentSchema>;

export const ListAppointmentsRequestSchema = z.object({
  insuredId: z.string().regex(/^[0-9]{5}$/, "El insuredId debe ser de 5 dígitos numéricos."),
});
export type ListAppointmentsRequestDto = z.infer<typeof ListAppointmentsRequestSchema>;

export const AppointmentResponseSchema = AppointmentSchema;
export type AppointmentResponseDto = z.infer<typeof AppointmentResponseSchema>;

export const SnsAppointmentEventSchema = z.object({
  appointmentId: z.string().uuid(),
  insuredId: z.string(),
  scheduleId: z.number(),
  countryISO: z.enum(['PE', 'CL']),
  createdAt: z.string().datetime(),
});
export type SnsAppointmentEventDto = z.infer<typeof SnsAppointmentEventSchema>;

export const UpdateAppointmentStatusEventSchema = z.object({
  appointmentId: z.string().uuid(),
  insuredId: z.string(),
  status: z.literal('PROCESSED'),
});

// ===== Directory: packages/core/src/application/use-cases =====

// CreateAppointment.ts
import { AppointmentEntity } from '../../domain/entities/Appointment';
import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';
import { IEventPublisher } from '../../domain/ports/IEventPublisher';
import { CreateAppointmentDto, AppointmentResponseDto } from '../dtos/AppointmentDtos';

export class CreateAppointmentUseCase {
  constructor(
    private readonly appointmentRepository: IAppointmentRepository,
    private readonly eventPublisher: IEventPublisher,
  ) {}

  async execute(dto: CreateAppointmentDto): Promise<AppointmentResponseDto> {
    const appointmentEntity = AppointmentEntity.create(dto);
    const appointment = appointmentEntity.values;

    await this.appointmentRepository.save(appointment);

    await this.eventPublisher.publish('AppointmentRequested', {
      appointmentId: appointment.appointmentId,
      insuredId: appointment.insuredId,
      scheduleId: appointment.scheduleId,
      countryISO: appointment.countryISO,
      createdAt: appointment.createdAt,
    }, {
      countryISO: {
        DataType: 'String',
        StringValue: appointment.countryISO,
      }
    });
    
    return appointment;
  }
}// ListAppointments.ts
import { Appointment } from '../../domain/entities/Appointment';
import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';

/**
 * @description Caso de uso para listar citas médicas por el ID del asegurado.
 */
export class ListAppointmentsUseCase {
  /**
   * @param appointmentRepository El repositorio para acceder a los datos de las citas.
   */
  constructor(
    private readonly appointmentRepository: IAppointmentRepository
  ) {}

  /**
   * Ejecuta el caso de uso.
   * @param insuredId El ID del asegurado.
   * @returns Una promesa que se resuelve con un arreglo de citas.
   */
  async execute(insuredId: string): Promise<Appointment[]> {
    return this.appointmentRepository.findByInsuredId(insuredId);
  }
}// ProcessAppointmentCL.ts
import { SnsAppointmentEventDto } from '../dtos/AppointmentDtos';
import { IConfirmationPublisher } from '../../domain/ports/IConfirmationPublisher';
import { Appointment } from '../../domain/entities/Appointment';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';

/**
 * @description Caso de uso para procesar una cita de CHILE.
 * Guarda en RDS y publica un evento de confirmación.
 */
export class ProcessAppointmentCLUseCase {
  constructor(
    private readonly rdsRepository: IAppointmentCountryRepository,
    private readonly confirmationPublisher: IConfirmationPublisher
  ) {}

  /**
   * Ejecuta el caso de uso para Chile.
   * @param appointmentEvent El DTO del evento recibido de SNS.
   */
  async execute(appointmentEvent: SnsAppointmentEventDto): Promise<void> {
    const appointmentToSave: Appointment = {
      ...appointmentEvent,
      status: 'PENDING',
      updatedAt: new Date(appointmentEvent.createdAt).toISOString(),
    };
    
    // Aquí iría la futura lógica de negocio específica para Chile.
    console.log(`Executing Chile-specific appointment processing for ID: ${appointmentEvent.appointmentId}`);

    await this.rdsRepository.save(appointmentToSave);

    await this.confirmationPublisher.publish({
      appointmentId: appointmentToSave.appointmentId,
      insuredId: appointmentToSave.insuredId,
      status: 'PROCESSED',
    });
  }
}// ProcessAppointmentPE.ts
import { SnsAppointmentEventDto } from '../dtos/AppointmentDtos';
import { IConfirmationPublisher } from '../../domain/ports/IConfirmationPublisher';
import { Appointment } from '../../domain/entities/Appointment';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';

/**
 * @description Caso de uso para procesar una cita de PERÚ.
 * Guarda en RDS y publica un evento de confirmación.
 */
export class ProcessAppointmentPEUseCase {
  constructor(
    private readonly rdsRepository: IAppointmentCountryRepository,
    private readonly confirmationPublisher: IConfirmationPublisher
  ) {}

  /**
   * Ejecuta el caso de uso para Perú.
   * @param appointmentEvent El DTO del evento recibido de SNS.
   */
  async execute(appointmentEvent: SnsAppointmentEventDto): Promise<void> {
    const appointmentToSave: Appointment = {
      ...appointmentEvent,
      status: 'PENDING',
      updatedAt: new Date(appointmentEvent.createdAt).toISOString(),
    };

    // Aquí iría la futura lógica de negocio específica para Perú.
    console.log(`Executing Peru-specific appointment processing for ID: ${appointmentEvent.appointmentId}`);

    await this.rdsRepository.save(appointmentToSave);

    await this.confirmationPublisher.publish({
      appointmentId: appointmentToSave.appointmentId,
      insuredId: appointmentToSave.insuredId,
      status: 'PROCESSED',
    });
  }
}// UpdateAppointmentStatus.ts
import { AppointmentEntity } from '../../domain/entities/Appointment';
import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';
import { AppError, ErrorCode, HttpStatusCode } from '../../common/errors/AppError';

interface UpdateAppointmentStatusDto {
  appointmentId: string;
  insuredId: string;
}

/**
 * @description Caso de uso para actualizar el estado de una cita a 'COMPLETED'.
 */
export class UpdateAppointmentStatusUseCase {
  constructor(
    private readonly appointmentRepository: IAppointmentRepository
  ) {}

  /**
   * Ejecuta el caso de uso.
   * @param dto El DTO con los identificadores de la cita.
   */
  async execute(dto: UpdateAppointmentStatusDto): Promise<void> {
    const { appointmentId, insuredId } = dto;

    // 1. Encontrar la cita existente
    const existingAppointment = await this.appointmentRepository.findById({ appointmentId, insuredId });

    if (!existingAppointment) {
      // En un sistema real, podríamos mover este mensaje a una DLQ o registrar una alerta.
      // Por ahora, lanzamos un error para indicar que la cita no fue encontrada.
      throw new AppError(
        `Appointment with ID ${appointmentId} not found.`,
        ErrorCode.NotFound,
        HttpStatusCode.NOT_FOUND
      );
    }
    
    // 2. Rehidratar la entidad de dominio
    const appointmentEntity = new AppointmentEntity(existingAppointment);

    // 3. Ejecutar la lógica de dominio para completar la cita
    appointmentEntity.complete();

    // 4. Persistir los cambios usando el repositorio
    await this.appointmentRepository.update(appointmentEntity.values);
    
    console.log(`Appointment ${appointmentId} status updated to COMPLETED.`);
  }
}

// ===== Directory: packages/core/src/common/errors =====

// AppError.ts
// (Reutilizar el código de AppError y sus subclases del proyecto anterior)
export enum ErrorCode {
	BadRequest = "BAD_REQUEST",
	NotFound = "NOT_FOUND",
	ServerError = "SERVER_ERROR",
}

export enum HttpStatusCode {
	BAD_REQUEST = 400,
	NOT_FOUND = 404,
	INTERNAL_SERVER_ERROR = 500,
}

export class AppError extends Error {
	constructor(
		message: string,
		public errorCode: ErrorCode,
		public statusCode: HttpStatusCode,
		public errors?: object[],
	) {
		super(message);
	}
}

// ===== Directory: packages/core/src/common/utils =====

// validation.ts
import { z, ZodError } from 'zod';
import { AppError, ErrorCode, HttpStatusCode } from '../errors/AppError';

/**
 * Valida y parsea un objeto de datos usando un esquema de Zod.
 * Si la validación falla, lanza un AppError estandarizado con los detalles.
 *
 * @template T El tipo inferido del esquema.
 * @param {z.ZodSchema<T>} schema El esquema de Zod para la validación.
 * @param {unknown} data Los datos a validar.
 * @returns {T} Los datos validados y tipados.
 * @throws {AppError} Si la validación falla.
 */
export function validateAndParse<T>(schema: z.ZodSchema<T>, data: unknown): T {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof ZodError) {
      // Lanza nuestro error personalizado adjuntando los detalles de Zod.
      throw new AppError(
        'La solicitud contiene datos inválidos.',
        ErrorCode.BadRequest,
        HttpStatusCode.BAD_REQUEST,
        error.issues, // Corregido: de 'errors' a 'issues'
      );
    }
    // Si es otro tipo de error, lo relanzamos.
    throw error;
  }
}

// ===== Directory: packages/core/src/domain/entities =====

// Appointment.ts
import { z } from 'zod';

export const AppointmentSchema = z.object({
  appointmentId: z.string().uuid(),
  insuredId: z.string().length(5),
  scheduleId: z.number().int().positive(),
  countryISO: z.enum(['PE', 'CL']),
  status: z.enum(['PENDING', 'COMPLETED', 'FAILED']),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});

export type Appointment = z.infer<typeof AppointmentSchema>;

export class AppointmentEntity {
  private props: Appointment;

  constructor(props: Appointment) {
    this.props = { ...props };
  }

  static create(props: Omit<Appointment, 'appointmentId' | 'status' | 'createdAt' | 'updatedAt'>): AppointmentEntity {
    const now = new Date().toISOString();
    return new AppointmentEntity({
      ...props,
      appointmentId: crypto.randomUUID(),
      status: 'PENDING',
      createdAt: now,
      updatedAt: now,
    });
  }

  get values(): Appointment {
    return this.props;
  }

  complete(): void {
    if (this.props.status !== 'PENDING') {
      // Aquí podrías lanzar un DomainError si fuera necesario
      return;
    }
    this.props.status = 'COMPLETED';
    this.props.updatedAt = new Date().toISOString();
  }
}

// ===== Directory: packages/core/src/domain/ports =====

// IConfirmationPublisher.ts
/**
 * @description Interfaz para un publicador de eventos de confirmación de procesamiento.
 */
export interface IConfirmationPublisher {
  /**
   * Publica un evento de confirmación.
   * @param eventDetail El payload del evento.
   */
  publish(eventDetail: Record<string, any>): Promise<void>;
}// IEventPublisher.ts
export interface IEventPublisher {
  publish(topic: string, event: Record<string, any>, attributes?: Record<string, any>): Promise<void>;
}

// ===== Directory: packages/core/src/domain/ports/repositories =====

// IAppointmentCountryRepository.ts
import { Appointment } from "../../entities/Appointment";
export interface IAppointmentCountryRepository {
  save(appointment: Appointment): Promise<void>;
}// IAppointmentRepository.ts
import { Appointment } from "../../entities/Appointment";

export interface IAppointmentRepository {
  save(appointment: Appointment): Promise<void>;
  findById(keys: { appointmentId: string, insuredId: string }): Promise<Appointment | null>; // [!code ++]
  update(appointment: Appointment): Promise<void>; // [!code ++]
  findByInsuredId(insuredId: string): Promise<Appointment[]>; // [!code ++]
}

// ===== Directory: packages/core =====

// tsconfig.json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*"]
}

// ===== Directory: packages/infrastructure =====

// package.json
{
  "name": "@infrastructure",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.583.0",
    "@aws-sdk/client-eventbridge": "^3.583.0",
    "@aws-sdk/client-sns": "^3.583.0",
    "@aws-sdk/lib-dynamodb": "^3.873.0",
    "@aws-sdk/util-dynamodb": "^3.583.0",
    "awilix": "^10.0.1",
    "mysql2": "^3.9.7",
    "zod": "^4.0.17"
  },
  "devDependencies": {
    "@types/mysql2": "github:types/mysql2"
  }
}

// ===== Directory: packages/infrastructure/src/common =====

// ErrorHandler.ts
import { AppError, ErrorCode, HttpStatusCode } from '@core/common/errors/AppError';

/**
 * Genera un log de error estructurado en formato JSON.
 * @param error El objeto de error capturado.
 */
function logError(error: Error | AppError): void {
  const logPayload = {
    level: "ERROR",
    timestamp: new Date().toISOString(),
    error: {
      name: error.name,
      message: error.message,
      stack: error.stack,
      ...((error instanceof AppError) && { // Agrega contexto si es un AppError
        code: error.errorCode,
        statusCode: error.statusCode,
        details: error.errors || [],
      }),
    }
  };
  console.error(JSON.stringify(logPayload, null, 2));
}

/**
 * Maneja los errores capturados en el Lambda y los convierte en una respuesta HTTP estándar.
 * También se encarga de registrar el error de forma estructurada.
 *
 * @param {unknown} error El error capturado.
 * @returns El objeto de respuesta HTTP para API Gateway.
 */
export function handleError(error: unknown) {
  if (error instanceof AppError) {
    logError(error);
    return {
      statusCode: error.statusCode,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        code: error.errorCode,
        message: error.message,
        ...(error.errors && { errors: error.errors }),
      }),
    };
  }

  // Captura de errores inesperados
  const unexpectedError = error instanceof Error
    ? error
    : new Error('An unexpected error occurred.');

  logError(unexpectedError);

  return {
    statusCode: HttpStatusCode.INTERNAL_SERVER_ERROR,
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      code: ErrorCode.ServerError,
      message: 'Ocurrió un error inesperado.',
    }),
  };
}// LambdaHandlerWrapper.ts
import { handleError } from './ErrorHandler';

/**
 * Wrapper de alto nivel para los manejadores de Lambda.
 * Se encarga de la ejecución, el manejo de respuestas exitosas y la delegación
 * de errores al manejador centralizado.
 *
 * @param handler La función del manejador de Lambda a ejecutar.
 */
export const lambdaHandlerWrapper = (handler: Function) => async (event: any, context: any) => {
  try {
    console.log('Request Event:', JSON.stringify(event, null, 2));
    const result = await handler(event, context);

    return {
      statusCode: result.statusCode || 200,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(result.body),
    };
  } catch (error: unknown) {
    // Toda la lógica de manejo de errores se delega a nuestro nuevo manejador.
    return handleError(error);
  }
};

// ===== Directory: packages/infrastructure/src/di =====

// container.ts
import { createContainer, asClass, InjectionMode } from 'awilix';
import { CreateAppointmentUseCase } from '@core/application/use-cases/CreateAppointment';
import { ListAppointmentsUseCase } from '@core/application/use-cases/ListAppointments';
import { UpdateAppointmentStatusUseCase } from '@core/application/use-cases/UpdateAppointmentStatus';
// Importamos los nuevos casos de uso
import { ProcessAppointmentPEUseCase } from '@core/application/use-cases/ProcessAppointmentPE';
import { ProcessAppointmentCLUseCase } from '@core/application/use-cases/ProcessAppointmentCL';
import { DynamoDbAppointmentRepository } from '../persistence/dynamodb/AppointmentRepository';
import { SnsEventPublisher } from '../messaging/SnsEventPublisher';
import { AppointmentRdsRepository } from '../persistence/rds/AppointmentRdsRepository';
import { EventBridgePublisher } from '../messaging/EventBridgePublisher';

const container = createContainer({
  injectionMode: InjectionMode.PROXY,
});

container.register({
  // Repositorios
  appointmentRepository: asClass(DynamoDbAppointmentRepository).singleton(),
  rdsRepository: asClass(AppointmentRdsRepository).singleton(),
  
  // Publicadores de Eventos
  eventPublisher: asClass(SnsEventPublisher).singleton(),
  confirmationPublisher: asClass(EventBridgePublisher).singleton(),

  // Casos de Uso
  createAppointmentUseCase: asClass(CreateAppointmentUseCase).singleton(),
  listAppointmentsUseCase: asClass(ListAppointmentsUseCase).singleton(),
  updateAppointmentStatusUseCase: asClass(UpdateAppointmentStatusUseCase).singleton(),
  
  // Registramos los nuevos casos de uso específicos y eliminamos el genérico
  processAppointmentPEUseCase: asClass(ProcessAppointmentPEUseCase).singleton(),
  processAppointmentCLUseCase: asClass(ProcessAppointmentCLUseCase).singleton(),
});

export { container };

// ===== Directory: packages/infrastructure/src/messaging =====

// EventBridgePublisher.ts
import { EventBridgeClient, PutEventsCommand } from '@aws-sdk/client-eventbridge';
import { IConfirmationPublisher } from '@core/domain/ports/IConfirmationPublisher';

/**
 * @description Publicador de eventos que utiliza AWS EventBridge.
 */
export class EventBridgePublisher implements IConfirmationPublisher {
  private readonly eventBridgeClient: EventBridgeClient;
  private readonly eventBusName = process.env.EVENT_BUS_NAME!;
  private readonly eventSource = 'appointment.processor';
  private readonly eventDetailType = 'AppointmentProcessed';

  constructor() {
    this.eventBridgeClient = new EventBridgeClient({
      region: process.env.AWS_REGION || 'us-east-1',
    });
  }

  /**
   * Publica un evento de confirmación en el bus de EventBridge.
   * @param detail El payload del evento.
   */
  async publish(detail: Record<string, any>): Promise<void> {
    const command = new PutEventsCommand({
      Entries: [
        {
          Source: this.eventSource,
          DetailType: this.eventDetailType,
          Detail: JSON.stringify(detail),
          EventBusName: this.eventBusName,
        },
      ],
    });

    try {
      await this.eventBridgeClient.send(command);
      console.log(`Event published successfully to EventBridge bus: ${this.eventBusName}`);
    } catch (error) {
      console.error('Error publishing event to EventBridge:', error);
      throw error;
    }
  }
}// SnsEventPublisher.ts
import { SNSClient, PublishCommand, MessageAttributeValue } from '@aws-sdk/client-sns';
import { IEventPublisher } from '@core/domain/ports/IEventPublisher';

/**
 * @description Implementación de IEventPublisher que publica eventos en un tópico de AWS SNS.
 */
export class SnsEventPublisher implements IEventPublisher {
  private readonly snsClient: SNSClient;
  private readonly topicArn = process.env.SNS_TOPIC_APPOINTMENTS_ARN!;

  constructor() {
    this.snsClient = new SNSClient({
      region: process.env.AWS_REGION || 'us-east-1',
      endpoint: process.env.IS_OFFLINE ? 'http://localhost:4002' : undefined,
    });
  }

  /**
   * Publica un evento en el tópico SNS configurado.
   * @param topic El nombre lógico del tema (no se usa directamente, se usa el ARN de la variable de entorno).
   * @param event El objeto del evento a publicar.
   * @param attributes Atributos del mensaje para filtrado en SNS.
   */
  async publish(topic: string, event: Record<string, any>, attributes?: Record<string, MessageAttributeValue>): Promise<void> {
    const command = new PublishCommand({
      TopicArn: this.topicArn,
      Message: JSON.stringify(event),
      MessageAttributes: attributes,
    });

    try {
      await this.snsClient.send(command);
      console.log(`Event published successfully to SNS topic: ${this.topicArn}`);
    } catch (error) {
      console.error('Error publishing event to SNS:', error);
      // En un caso real, aquí se podría implementar una estrategia de reintentos o "dead-letter queue".
      throw error;
    }
  }
}

// ===== Directory: packages/infrastructure/src/persistence/dynamodb =====

// AppointmentRepository.ts
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand, QueryCommand, GetCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { Appointment } from '@core/domain/entities/Appointment';

export class DynamoDbAppointmentRepository implements IAppointmentRepository {
  private readonly docClient: DynamoDBDocumentClient;
  private readonly tableName = process.env.DYNAMODB_TABLE_APPOINTMENTS!;

  constructor() {
    const client = new DynamoDBClient({
      endpoint: process.env.IS_OFFLINE ? 'http://localhost:8000' : undefined,
    });
    this.docClient = DynamoDBDocumentClient.from(client);
  }

  async save(appointment: Appointment): Promise<void> {
    const command = new PutCommand({
      TableName: this.tableName,
      Item: appointment,
    });
    await this.docClient.send(command);
  }

  async findById(keys: { appointmentId: string; insuredId: string }): Promise<Appointment | null> {
    const command = new GetCommand({
      TableName: this.tableName,
      Key: {
        insuredId: keys.insuredId,
        appointmentId: keys.appointmentId,
      },
    });
    const { Item } = await this.docClient.send(command);
    return (Item as Appointment) || null;
  }

  async update(appointment: Appointment): Promise<void> {
    const command = new UpdateCommand({
      TableName: this.tableName,
      Key: {
        insuredId: appointment.insuredId,
        appointmentId: appointment.appointmentId,
      },
      UpdateExpression: 'set #status = :status, updatedAt = :updatedAt',
      ExpressionAttributeNames: {
        '#status': 'status', // 'status' es una palabra reservada en DynamoDB
      },
      ExpressionAttributeValues: {
        ':status': appointment.status,
        ':updatedAt': appointment.updatedAt,
      },
    });
    await this.docClient.send(command);
  }
  
  async findByInsuredId(insuredId: string): Promise<Appointment[]> {
    const command = new QueryCommand({
      TableName: this.tableName,
      KeyConditionExpression: 'insuredId = :insuredId',
      ExpressionAttributeValues: {
        ':insuredId': insuredId,
      },
    });

    const { Items } = await this.docClient.send(command);
    return (Items as Appointment[]) || [];
  }
}

// ===== Directory: packages/infrastructure/src/persistence/rds =====

// AppointmentRdsRepository.ts
import { createPool, Pool } from 'mysql2/promise';
import { Appointment } from '@core/domain/entities/Appointment';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';

/**
 * @description Repositorio para manejar la persistencia de citas en una base de datos RDS (MySQL).
 * Asume una tabla `appointments` con la siguiente estructura (o similar):
 * CREATE TABLE appointments (
 * appointment_id VARCHAR(36) PRIMARY KEY,
 * insured_id VARCHAR(5) NOT NULL,
 * schedule_id INT NOT NULL,
 * country_iso VARCHAR(2) NOT NULL,
 * status VARCHAR(10) NOT NULL,
 * created_at TIMESTAMP NOT NULL
 * );
 */
export class AppointmentRdsRepository implements IAppointmentCountryRepository {

  constructor() {
    
  }

  /**
   * Guarda una cita en la base de datos MySQL.
   * @param appointment El objeto de la cita a persistir.
   */
  async save(appointment: Appointment): Promise<void> {
    const sql = `
      INSERT INTO appointments (appointment_id, insured_id, schedule_id, country_iso, status, created_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `;
    try {
     
      console.log(`Appointment SQL: ${sql}`);
      console.log(`Appointment ${appointment.appointmentId} saved to RDS.`);
    } catch (error) {
      console.error('Error saving appointment to RDS:', error);
      throw new Error('Failed to save appointment to RDS.');
    }
  }
}

// ===== Directory: packages/test/core/application/use-cases =====

// CreateAppointment.test.ts
import { CreateAppointmentUseCase } from '@core/application/use-cases/CreateAppointment';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { IEventPublisher } from '@core/domain/ports/IEventPublisher';
import { CreateAppointmentDto } from '@core/application/dtos/AppointmentDtos';

// Mockear crypto.randomUUID para tener un ID predecible en las pruebas
const MOCK_APPOINTMENT_ID = 'e7a4b0c4-9a2d-4f1e-8c6c-5e4a3b2a1f0e';
global.crypto = {
  ...global.crypto,
  randomUUID: () => MOCK_APPOINTMENT_ID,
};

describe('CreateAppointmentUseCase', () => {
  let appointmentRepository: jest.Mocked<IAppointmentRepository>;
  let eventPublisher: jest.Mocked<IEventPublisher>;
  let createAppointmentUseCase: CreateAppointmentUseCase;

  beforeEach(() => {
    appointmentRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      findByInsuredId: jest.fn(),
    };

    eventPublisher = {
      publish: jest.fn(),
    };

    createAppointmentUseCase = new CreateAppointmentUseCase(
      appointmentRepository,
      eventPublisher,
    );
  });

  it('debe crear una cita, guardarla en el repositorio y publicar un evento', async () => {
    // Arrange
    const dto: CreateAppointmentDto = {
      insuredId: '54321',
      scheduleId: 200,
      countryISO: 'CL',
    };

    // Act
    const result = await createAppointmentUseCase.execute(dto);

    // Assert
    expect(appointmentRepository.save).toHaveBeenCalledTimes(1);
    const savedAppointment = appointmentRepository.save.mock.calls[0][0];
    expect(savedAppointment).toMatchObject({
      appointmentId: MOCK_APPOINTMENT_ID,
      insuredId: '54321',
      scheduleId: 200,
      countryISO: 'CL',
      status: 'PENDING',
      createdAt: expect.any(String),
      updatedAt: expect.any(String),
    });

    expect(eventPublisher.publish).toHaveBeenCalledTimes(1);
    const [topic, eventPayload, attributes] = eventPublisher.publish.mock.calls[0];
    expect(topic).toBe('AppointmentRequested');
    expect(eventPayload).toMatchObject({
      appointmentId: MOCK_APPOINTMENT_ID,
      insuredId: '54321',
      scheduleId: 200,
      countryISO: 'CL',
      createdAt: savedAppointment.createdAt,
    });
    expect(attributes).toEqual({
      countryISO: {
        DataType: 'String',
        StringValue: 'CL',
      },
    });

    expect(result).toEqual(savedAppointment);
  });
});// ListAppointments.test.ts
import { ListAppointmentsUseCase } from '@core/application/use-cases/ListAppointments';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { Appointment } from '@core/domain/entities/Appointment';

describe('ListAppointmentsUseCase', () => {
  let appointmentRepository: jest.Mocked<IAppointmentRepository>;
  let listAppointmentsUseCase: ListAppointmentsUseCase;

  beforeEach(() => {
    appointmentRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      findByInsuredId: jest.fn(),
    };
    listAppointmentsUseCase = new ListAppointmentsUseCase(appointmentRepository);
  });

  it('debe devolver una lista de citas para un asegurado existente', async () => {
    // Arrange
    const insuredId = '11223';
    const mockAppointments: Appointment[] = [
      {
        appointmentId: 'uuid-1',
        insuredId,
        scheduleId: 1,
        countryISO: 'PE',
        status: 'PENDING',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      },
      {
        appointmentId: 'uuid-2',
        insuredId,
        scheduleId: 2,
        countryISO: 'PE',
        status: 'COMPLETED',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      },
    ];
    appointmentRepository.findByInsuredId.mockResolvedValue(mockAppointments);

    // Act
    const result = await listAppointmentsUseCase.execute(insuredId);

    // Assert
    expect(appointmentRepository.findByInsuredId).toHaveBeenCalledWith(insuredId);
    expect(result).toHaveLength(2);
    expect(result).toEqual(mockAppointments);
  });

  it('debe devolver un arreglo vacío si el asegurado no tiene citas', async () => {
    // Arrange
    const insuredId = '33445';
    appointmentRepository.findByInsuredId.mockResolvedValue([]);

    // Act
    const result = await listAppointmentsUseCase.execute(insuredId);

    // Assert
    expect(appointmentRepository.findByInsuredId).toHaveBeenCalledWith(insuredId);
    expect(result).toHaveLength(0);
    expect(result).toEqual([]);
  });
});// ProcessAppointmentCL.test.ts
import { ProcessAppointmentCLUseCase } from '@core/application/use-cases/ProcessAppointmentCL';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';
import { IConfirmationPublisher } from '@core/domain/ports/IConfirmationPublisher';
import { SnsAppointmentEventDto } from '@core/application/dtos/AppointmentDtos';

describe('ProcessAppointmentCLUseCase', () => {
  let rdsRepository: jest.Mocked<IAppointmentCountryRepository>;
  let confirmationPublisher: jest.Mocked<IConfirmationPublisher>;
  let useCase: ProcessAppointmentCLUseCase;

  beforeEach(() => {
    rdsRepository = { save: jest.fn() };
    confirmationPublisher = { publish: jest.fn() };
    useCase = new ProcessAppointmentCLUseCase(rdsRepository, confirmationPublisher);
  });

  it('debe guardar la cita en RDS y publicar un evento de confirmación', async () => {
    // Arrange
    const eventDto: SnsAppointmentEventDto = {
      appointmentId: 'uuid-cl-1',
      insuredId: '55555',
      scheduleId: 400,
      countryISO: 'CL',
      createdAt: new Date().toISOString(),
    };

    // Act
    await useCase.execute(eventDto);

    // Assert
    expect(rdsRepository.save).toHaveBeenCalledTimes(1);
    const savedAppointment = rdsRepository.save.mock.calls[0][0];
    expect(savedAppointment).toMatchObject({
      ...eventDto,
      status: 'PENDING',
      updatedAt: eventDto.createdAt,
    });

    expect(confirmationPublisher.publish).toHaveBeenCalledTimes(1);
    const publishedEvent = confirmationPublisher.publish.mock.calls[0][0];
    expect(publishedEvent).toEqual({
      appointmentId: eventDto.appointmentId,
      insuredId: eventDto.insuredId,
      status: 'PROCESSED',
    });
  });
});// ProcessAppointmentPE.test.ts
import { ProcessAppointmentPEUseCase } from '@core/application/use-cases/ProcessAppointmentPE';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';
import { IConfirmationPublisher } from '@core/domain/ports/IConfirmationPublisher';
import { SnsAppointmentEventDto } from '@core/application/dtos/AppointmentDtos';

describe('ProcessAppointmentPEUseCase', () => {
  let rdsRepository: jest.Mocked<IAppointmentCountryRepository>;
  let confirmationPublisher: jest.Mocked<IConfirmationPublisher>;
  let useCase: ProcessAppointmentPEUseCase;

  beforeEach(() => {
    rdsRepository = { save: jest.fn() };
    confirmationPublisher = { publish: jest.fn() };
    useCase = new ProcessAppointmentPEUseCase(rdsRepository, confirmationPublisher);
  });

  it('debe guardar la cita en RDS y publicar un evento de confirmación', async () => {
    // Arrange
    const eventDto: SnsAppointmentEventDto = {
      appointmentId: 'uuid-pe-1',
      insuredId: '98765',
      scheduleId: 300,
      countryISO: 'PE',
      createdAt: new Date().toISOString(),
    };

    // Act
    await useCase.execute(eventDto);

    // Assert
    expect(rdsRepository.save).toHaveBeenCalledTimes(1);
    const savedAppointment = rdsRepository.save.mock.calls[0][0];
    expect(savedAppointment).toMatchObject({
      ...eventDto,
      status: 'PENDING',
      updatedAt: eventDto.createdAt,
    });

    expect(confirmationPublisher.publish).toHaveBeenCalledTimes(1);
    const publishedEvent = confirmationPublisher.publish.mock.calls[0][0];
    expect(publishedEvent).toEqual({
      appointmentId: eventDto.appointmentId,
      insuredId: eventDto.insuredId,
      status: 'PROCESSED',
    });
  });
});// UpdateAppointmentStatus.test.ts
import { UpdateAppointmentStatusUseCase } from '@core/application/use-cases/UpdateAppointmentStatus';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { Appointment } from '@core/domain/entities/Appointment';
import { AppError, ErrorCode } from '@core/common/errors/AppError';

describe('UpdateAppointmentStatusUseCase', () => {
  let appointmentRepository: jest.Mocked<IAppointmentRepository>;
  let useCase: UpdateAppointmentStatusUseCase;

  beforeEach(() => {
    appointmentRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      findByInsuredId: jest.fn(),
    };
    useCase = new UpdateAppointmentStatusUseCase(appointmentRepository);
  });

  it('debe actualizar el estado de una cita a COMPLETED', async () => {
    // Arrange
    const dto = { appointmentId: 'uuid-1', insuredId: '12345' };
    const existingAppointment: Appointment = {
      ...dto,
      scheduleId: 1,
      countryISO: 'PE',
      status: 'PENDING',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    appointmentRepository.findById.mockResolvedValue(existingAppointment);

    // Act
    await useCase.execute(dto);

    // Assert
    expect(appointmentRepository.findById).toHaveBeenCalledWith(dto);
    expect(appointmentRepository.update).toHaveBeenCalledTimes(1);
    const updatedAppointment = appointmentRepository.update.mock.calls[0][0];
    expect(updatedAppointment.status).toBe('COMPLETED');
    expect(new Date(updatedAppointment.updatedAt).getTime()).toBeGreaterThan(new Date(existingAppointment.updatedAt).getTime());
  });

  it('debe lanzar un AppError si la cita no se encuentra', async () => {
    // Arrange
    const dto = { appointmentId: 'uuid-not-found', insuredId: '12345' };
    appointmentRepository.findById.mockResolvedValue(null);

    // Act & Assert
    await expect(useCase.execute(dto)).rejects.toThrow(
      new AppError(
        `Appointment with ID ${dto.appointmentId} not found.`,
        ErrorCode.NotFound,
        404
      )
    );
  });
});

// ===== Directory: packages/test/core/common/utils =====

// validation.test.ts
import { z, ZodError } from 'zod';
import { validateAndParse } from '@core/common/utils/validation';
import { AppError, ErrorCode, HttpStatusCode } from '@core/common/errors/AppError';

// 1. Definimos un esquema simple para usar en las pruebas
const testSchema = z.object({
  name: z.string().min(3),
  age: z.number().positive(),
});

describe('validateAndParse', () => {

  // Test Case 1: El camino feliz, cuando los datos son válidos
  it('debe devolver los datos parseados cuando la validación es exitosa', () => {
    // Arrange
    const validData = { name: 'John Doe', age: 30 };

    // Act
    const result = validateAndParse(testSchema, validData);

    // Assert
    expect(result).toEqual(validData);
  });

  // Test Case 2: Cuando los datos no cumplen con el esquema de Zod
  it('debe lanzar un AppError estandarizado cuando la validación de Zod falla', () => {
    // Arrange
    const invalidData = { name: 'Jo', age: -5 }; // Nombre muy corto y edad negativa

    // Act & Assert
    try {
      validateAndParse(testSchema, invalidData);
      // Si llegamos aquí, la prueba falló porque no se lanzó un error
      fail('La función no lanzó ningún error');
    } catch (error) {
      expect(error).toBeInstanceOf(AppError);
      
      const appError = error as AppError;
      expect(appError.message).toBe('La solicitud contiene datos inválidos.');
      expect(appError.errorCode).toBe(ErrorCode.BadRequest);
      expect(appError.statusCode).toBe(HttpStatusCode.BAD_REQUEST);
      
      // Verificamos que los detalles del error de Zod se adjuntaron
      expect(appError.errors).toBeDefined();
      expect(Array.isArray(appError.errors)).toBe(true);
      expect(appError.errors?.length).toBe(2); // Esperamos dos errores de validación
    }
  });

  // Test Case 3: Cuando ocurre un error que no es de Zod
  it('debe relanzar el error si no es una instancia de ZodError', () => {
    // Arrange
    const unexpectedError = new Error('Error inesperado en la base de datos');
    
    // Creamos un esquema simulado que siempre lanza un error genérico
    const mockSchemaWithError = {
      parse: () => {
        throw unexpectedError;
      },
    } as any;

    // Act & Assert
    expect(() => {
      validateAndParse(mockSchemaWithError, {});
    }).toThrow(unexpectedError);
  });
});

// ===== Directory: . =====

// pnpm-workspace.yaml
# pnpm-workspace.yaml
packages:
  # Todos los paquetes en la carpeta 'packages'
  - 'packages/*'
  # Todos los servicios en la carpeta 'services'
  - 'services/*'// README.md
# test-medical-appointments


// ===== Directory: services/appointment-api/.serverless =====

// meta.json
{
  "/Users/jcampos/test-medical-appointments/services/appointment-api/serverless.yml": {
    "versionFramework": "4.18.1",
    "servicePath": "/Users/jcampos/test-medical-appointments/services/appointment-api/serverless.yml",
    "serviceConfigFileName": "serverless.yml",
    "service": {
      "org": "aivoxia",
      "service": "appointment-api",
      "provider": {
        "name": "aws",
        "runtime": "nodejs20.x",
        "region": "us-east-2",
        "stage": "dev",
        "tags": {
          "app-id": "test-medical-appoinments",
          "app-center-cost": "test-medical-appoinments",
          "app-env": "test"
        },
        "environment": {
          "DYNAMODB_TABLE_APPOINTMENTS": "appointments-table-dev",
          "SNS_TOPIC_APPOINTMENTS_ARN": {
            "Ref": "AppointmentsTopic"
          }
        },
        "versionFunctions": true
      },
      "plugins": [
        "serverless-esbuild",
        "serverless-offline",
        "serverless-dynamodb-local"
      ],
      "package": {
        "individually": true
      },
      "custom": {
        "tableName": "appointments-table-dev",
        "esbuild": {
          "bundle": true,
          "minify": false,
          "sourcemap": true,
          "packager": "pnpm"
        },
        "dynamodb": {
          "start": {
            "port": 8000,
            "inMemory": true,
            "migrate": true
          }
        }
      },
      "functions": {
        "createAppointment": {
          "handler": "src/handlers/createAppointment.handler",
          "events": [
            {
              "httpApi": {
                "path": "/appointments",
                "method": "post"
              }
            }
          ]
        },
        "listAppointments": {
          "handler": "src/handlers/listAppointments.handler",
          "events": [
            {
              "httpApi": {
                "path": "/appointments/{insuredId}",
                "method": "get"
              }
            }
          ]
        },
        "updateAppointmentStatus": {
          "handler": "src/handlers/updateAppointmentStatus.handler",
          "events": [
            {
              "sqs": {
                "arn": {
                  "Fn::GetAtt": [
                    "AppointmentsCompletionQueue",
                    "Arn"
                  ]
                }
              }
            }
          ]
        }
      },
      "resources": {
        "Resources": {
          "AppointmentsTable": {
            "Type": "AWS::DynamoDB::Table",
            "Properties": {
              "TableName": "appointments-table-dev",
              "AttributeDefinitions": [
                {
                  "AttributeName": "insuredId",
                  "AttributeType": "S"
                },
                {
                  "AttributeName": "appointmentId",
                  "AttributeType": "S"
                }
              ],
              "KeySchema": [
                {
                  "AttributeName": "insuredId",
                  "KeyType": "HASH"
                },
                {
                  "AttributeName": "appointmentId",
                  "KeyType": "RANGE"
                }
              ],
              "BillingMode": "PAY_PER_REQUEST"
            }
          },
          "AppointmentsTopic": {
            "Type": "AWS::SNS::Topic",
            "Properties": {
              "TopicName": "appointments-topic-dev"
            }
          },
          "AppointmentsQueuePE": {
            "Type": "AWS::SQS::Queue",
            "Properties": {
              "QueueName": "appointments-queue-pe-dev"
            }
          },
          "AppointmentsQueueCL": {
            "Type": "AWS::SQS::Queue",
            "Properties": {
              "QueueName": "appointments-queue-cl-dev"
            }
          },
          "SnsSubscriptionPE": {
            "Type": "AWS::SNS::Subscription",
            "Properties": {
              "Protocol": "sqs",
              "Endpoint": {
                "Fn::GetAtt": [
                  "AppointmentsQueuePE",
                  "Arn"
                ]
              },
              "TopicArn": {
                "Ref": "AppointmentsTopic"
              },
              "FilterPolicy": {
                "countryISO": [
                  "PE"
                ]
              },
              "RawMessageDelivery": "true"
            }
          },
          "SnsSubscriptionCL": {
            "Type": "AWS::SNS::Subscription",
            "Properties": {
              "Protocol": "sqs",
              "Endpoint": {
                "Fn::GetAtt": [
                  "AppointmentsQueueCL",
                  "Arn"
                ]
              },
              "TopicArn": {
                "Ref": "AppointmentsTopic"
              },
              "FilterPolicy": {
                "countryISO": [
                  "CL"
                ]
              },
              "RawMessageDelivery": "true"
            }
          },
          "SqsPolicy": {
            "Type": "AWS::SQS::QueuePolicy",
            "Properties": {
              "Queues": [
                {
                  "Ref": "AppointmentsQueuePE"
                },
                {
                  "Ref": "AppointmentsQueueCL"
                }
              ],
              "PolicyDocument": {
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": {
                      "Service": "sns.amazonaws.com"
                    },
                    "Action": "sqs:SendMessage",
                    "Resource": "*",
                    "Condition": {
                      "ArnEquals": {
                        "aws:SourceArn": {
                          "Ref": "AppointmentsTopic"
                        }
                      }
                    }
                  }
                ]
              }
            }
          },
          "AppointmentEventBus": {
            "Type": "AWS::Events::EventBus",
            "Properties": {
              "Name": "appointment-event-bus-dev"
            }
          },
          "AppointmentsCompletionQueue": {
            "Type": "AWS::SQS::Queue",
            "Properties": {
              "QueueName": "appointments-completion-queue-dev"
            }
          },
          "EventBusToSqsRule": {
            "Type": "AWS::Events::Rule",
            "Properties": {
              "EventBusName": {
                "Ref": "AppointmentEventBus"
              },
              "EventPattern": {
                "source": [
                  "appointment.processor"
                ]
              },
              "Targets": [
                {
                  "Arn": {
                    "Fn::GetAtt": [
                      "AppointmentsCompletionQueue",
                      "Arn"
                    ]
                  },
                  "Id": "CompletionQueueTarget"
                }
              ]
            }
          },
          "EventBridgeToSqsPolicy": {
            "Type": "AWS::SQS::QueuePolicy",
            "Properties": {
              "Queues": [
                {
                  "Ref": "AppointmentsCompletionQueue"
                }
              ],
              "PolicyDocument": {
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": {
                      "Service": "events.amazonaws.com"
                    },
                    "Action": "sqs:SendMessage",
                    "Resource": {
                      "Fn::GetAtt": [
                        "AppointmentsCompletionQueue",
                        "Arn"
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    },
    "provider": {
      "name": "aws",
      "runtime": "nodejs20.x",
      "region": "us-east-2",
      "stage": "dev",
      "tags": {
        "app-id": "test-medical-appoinments",
        "app-center-cost": "test-medical-appoinments",
        "app-env": "test"
      },
      "environment": {
        "DYNAMODB_TABLE_APPOINTMENTS": "appointments-table-dev",
        "SNS_TOPIC_APPOINTMENTS_ARN": {
          "Ref": "AppointmentsTopic"
        }
      },
      "versionFunctions": true
    },
    "dashboard": {
      "isEnabledForService": false,
      "requiredAuthentication": false,
      "orgFeaturesInUse": null,
      "orgObservabilityIntegrations": null,
      "serviceAppId": null,
      "serviceProvider": null,
      "instanceParameters": null
    },
    "error": {
      "message": "Serverless now includes ESBuild and supports Typescript out-of-the-box. But this conflicts with the plugin 'serverless-esbuild'.\nYou can either remove this plugin and try Serverless's ESBuild support builtin, or you can set 'build.esbuild' to false in your 'serverless.yml'.\nFor more information go to, https://slss.io/buildoptions",
      "stack": "ServerlessError2: Serverless now includes ESBuild and supports Typescript out-of-the-box. But this conflicts with the plugin 'serverless-esbuild'.\nYou can either remove this plugin and try Serverless's ESBuild support builtin, or you can set 'build.esbuild' to false in your 'serverless.yml'.\nFor more information go to, https://slss.io/buildoptions\n    at PluginManager.addPlugin (file:///Users/jcampos/.serverless/releases/4.18.1/package/dist/sf-core.js:1398:65)\n    at file:///Users/jcampos/.serverless/releases/4.18.1/package/dist/sf-core.js:1398:1734\n    at Array.forEach (<anonymous>)\n    at PluginManager.loadAllPlugins (file:///Users/jcampos/.serverless/releases/4.18.1/package/dist/sf-core.js:1398:1712)\n    at async Serverless.init (file:///Users/jcampos/.serverless/releases/4.18.1/package/dist/sf-core.js:1405:9843)\n    at async runFramework (file:///Users/jcampos/.serverless/releases/4.18.1/package/dist/sf-core.js:1432:839)\n    at async TraditionalRunner.run (file:///Users/jcampos/.serverless/releases/4.18.1/package/dist/sf-core.js:1428:28331)\n    at async route (file:///Users/jcampos/.serverless/releases/4.18.1/package/dist/sf-core.js:1603:2878)\n    at async Object.run (file:///Users/jcampos/.serverless/releases/4.18.1/package/dist/sf-core.js:1604:3661)\n    at async run2 (file:///Users/jcampos/.serverless/releases/4.18.1/package/dist/sf-core.js:1604:4815)",
      "code": "PLUGIN_TYPESCRIPT_CONFLICT"
    },
    "serviceRawFile": "# \"org\" ensures this Service is used with the correct Serverless Framework Access Key.\norg: aivoxia\nservice: appointment-api\n\nprovider:\n  name: aws\n  runtime: nodejs20.x\n  region: ${opt:region, 'us-east-2'}\n  stage: ${opt:stage, 'dev'}\n  # Añadimos tags que se aplicarán a todos los recursos de la stack\n  tags:\n    app-id: test-medical-appoinments\n    app-center-cost: test-medical-appoinments\n    app-env: test\n  environment:\n    DYNAMODB_TABLE_APPOINTMENTS: ${self:custom.tableName}\n    SNS_TOPIC_APPOINTMENTS_ARN: { \"Ref\": \"AppointmentsTopic\" }\n\nplugins:\n  - serverless-esbuild\n  - serverless-offline\n  - serverless-dynamodb-local\n\npackage:\n  individually: true\n\ncustom:\n  tableName: appointments-table-${self:provider.stage}\n  esbuild:\n    bundle: true\n    minify: false\n    sourcemap: true\n    packager: pnpm\n  dynamodb:\n    start:\n      port: 8000\n      inMemory: true\n      migrate: true\n\nfunctions:\n  createAppointment:\n    handler: src/handlers/createAppointment.handler\n    events:\n      - httpApi:\n          path: /appointments\n          method: post\n  \n  listAppointments:\n    handler: src/handlers/listAppointments.handler\n    events:\n      - httpApi:\n          path: /appointments/{insuredId}\n          method: get\n          \n  updateAppointmentStatus:\n    handler: src/handlers/updateAppointmentStatus.handler\n    events:\n      - sqs:\n          arn:\n            Fn::GetAtt: [AppointmentsCompletionQueue, Arn]\n\nresources:\n  Resources:\n    AppointmentsTable:\n      Type: AWS::DynamoDB::Table\n      Properties:\n        TableName: ${self:custom.tableName}\n        AttributeDefinitions:\n          - AttributeName: insuredId\n            AttributeType: S\n          - AttributeName: appointmentId\n            AttributeType: S\n        KeySchema:\n          - AttributeName: insuredId\n            KeyType: HASH\n          - AttributeName: appointmentId\n            KeyType: RANGE\n        BillingMode: PAY_PER_REQUEST\n    \n    AppointmentsTopic:\n      Type: AWS::SNS::Topic\n      Properties:\n        TopicName: appointments-topic-${self:provider.stage}\n\n    AppointmentsQueuePE:\n      Type: AWS::SQS::Queue\n      Properties:\n        QueueName: appointments-queue-pe-${self:provider.stage}\n\n    AppointmentsQueueCL:\n      Type: AWS::SQS::Queue\n      Properties:\n        QueueName: appointments-queue-cl-${self:provider.stage}\n\n    SnsSubscriptionPE:\n      Type: AWS::SNS::Subscription\n      Properties:\n        Protocol: sqs\n        Endpoint: { \"Fn::GetAtt\": [\"AppointmentsQueuePE\", \"Arn\"] }\n        TopicArn: { \"Ref\": \"AppointmentsTopic\" }\n        FilterPolicy:\n          countryISO: [\"PE\"]\n        RawMessageDelivery: \"true\"\n\n    SnsSubscriptionCL:\n      Type: AWS::SNS::Subscription\n      Properties:\n        Protocol: sqs\n        Endpoint: { \"Fn::GetAtt\": [\"AppointmentsQueueCL\", \"Arn\"] }\n        TopicArn: { \"Ref\": \"AppointmentsTopic\" }\n        FilterPolicy:\n          countryISO: [\"CL\"]\n        RawMessageDelivery: \"true\"\n\n    SqsPolicy:\n      Type: AWS::SQS::QueuePolicy\n      Properties:\n        Queues:\n          - { \"Ref\": \"AppointmentsQueuePE\" }\n          - { \"Ref\": \"AppointmentsQueueCL\" }\n        PolicyDocument:\n          Statement:\n            - Effect: \"Allow\"\n              Principal:\n                Service: \"sns.amazonaws.com\"\n              Action: \"sqs:SendMessage\"\n              Resource: \"*\"\n              Condition:\n                ArnEquals:\n                  aws:SourceArn: { \"Ref\": \"AppointmentsTopic\" }\n    \n    AppointmentEventBus:\n      Type: AWS::Events::EventBus\n      Properties:\n        Name: appointment-event-bus-${self:provider.stage}\n        \n    AppointmentsCompletionQueue:\n      Type: AWS::SQS::Queue\n      Properties:\n        QueueName: appointments-completion-queue-${self:provider.stage}\n        \n    EventBusToSqsRule:\n      Type: AWS::Events::Rule\n      Properties:\n        EventBusName: { \"Ref\": \"AppointmentEventBus\" }\n        EventPattern:\n          source:\n            - \"appointment.processor\"\n        Targets:\n          - Arn: { \"Fn::GetAtt\": [\"AppointmentsCompletionQueue\", \"Arn\"] }\n            Id: \"CompletionQueueTarget\"\n            \n    EventBridgeToSqsPolicy:\n      Type: AWS::SQS::QueuePolicy\n      Properties:\n        Queues:\n          - Ref: AppointmentsCompletionQueue\n        PolicyDocument:\n          Statement:\n            - Effect: Allow\n              Principal:\n                Service: events.amazonaws.com\n              Action: sqs:SendMessage\n              Resource: { \"Fn::GetAtt\": [\"AppointmentsCompletionQueue\", \"Arn\"] }",
    "command": [
      "offline",
      "start"
    ],
    "options": {},
    "orgId": "1380abf4-7a7b-44ab-b514-b102c1c96e9c",
    "orgName": "aivoxia",
    "userId": "2tcSJYLFgJ4JsHK4SY",
    "userName": "aivoxia",
    "serviceProviderAwsAccountId": "941958612220",
    "serviceProviderAwsCfStackId": null,
    "serviceProviderAwsCfStackCreated": null,
    "serviceProviderAwsCfStackUpdated": null,
    "serviceProviderAwsCfStackStatus": null,
    "serviceProviderAwsCfStackOutputs": null
  }
}

// ===== Directory: services/appointment-api =====

// serverless.yml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: aivoxia
service: appointment-api

provider:
  name: aws
  runtime: nodejs20.x
  region: ${opt:region, 'us-east-2'}
  stage: ${opt:stage, 'dev'}
  # Añadimos tags que se aplicarán a todos los recursos de la stack
  tags:
    app-id: test-medical-appoinments
    app-center-cost: test-medical-appoinments
    app-env: test
  environment:
    DYNAMODB_TABLE_APPOINTMENTS: ${self:custom.tableName}
    SNS_TOPIC_APPOINTMENTS_ARN: { "Ref": "AppointmentsTopic" }

plugins:
  - serverless-offline
  - serverless-dynamodb-local

package:
  individually: true

custom:
  tableName: appointments-table-${self:provider.stage}
  dynamodb:
    start:
      port: 8000
      inMemory: true
      migrate: true

functions:
  createAppointment:
    handler: src/handlers/createAppointment.handler
    events:
      - httpApi:
          path: /appointments
          method: post
  
  listAppointments:
    handler: src/handlers/listAppointments.handler
    events:
      - httpApi:
          path: /appointments/{insuredId}
          method: get
          
  updateAppointmentStatus:
    handler: src/handlers/updateAppointmentStatus.handler
    events:
      - sqs:
          arn:
            Fn::GetAtt: [AppointmentsCompletionQueue, Arn]

resources:
  Resources:
    AppointmentsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tableName}
        AttributeDefinitions:
          - AttributeName: insuredId
            AttributeType: S
          - AttributeName: appointmentId
            AttributeType: S
        KeySchema:
          - AttributeName: insuredId
            KeyType: HASH
          - AttributeName: appointmentId
            KeyType: RANGE
        BillingMode: PAY_PER_REQUEST
    
    AppointmentsTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: appointments-topic-${self:provider.stage}

    AppointmentsQueuePE:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: appointments-queue-pe-${self:provider.stage}

    AppointmentsQueueCL:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: appointments-queue-cl-${self:provider.stage}

    SnsSubscriptionPE:
      Type: AWS::SNS::Subscription
      Properties:
        Protocol: sqs
        Endpoint: { "Fn::GetAtt": ["AppointmentsQueuePE", "Arn"] }
        TopicArn: { "Ref": "AppointmentsTopic" }
        FilterPolicy:
          countryISO: ["PE"]
        RawMessageDelivery: "true"

    SnsSubscriptionCL:
      Type: AWS::SNS::Subscription
      Properties:
        Protocol: sqs
        Endpoint: { "Fn::GetAtt": ["AppointmentsQueueCL", "Arn"] }
        TopicArn: { "Ref": "AppointmentsTopic" }
        FilterPolicy:
          countryISO: ["CL"]
        RawMessageDelivery: "true"

    SqsPolicy:
      Type: AWS::SQS::QueuePolicy
      Properties:
        Queues:
          - { "Ref": "AppointmentsQueuePE" }
          - { "Ref": "AppointmentsQueueCL" }
        PolicyDocument:
          Statement:
            - Effect: "Allow"
              Principal:
                Service: "sns.amazonaws.com"
              Action: "sqs:SendMessage"
              Resource: "*"
              Condition:
                ArnEquals:
                  aws:SourceArn: { "Ref": "AppointmentsTopic" }
    
    AppointmentEventBus:
      Type: AWS::Events::EventBus
      Properties:
        Name: appointment-event-bus-${self:provider.stage}
        
    AppointmentsCompletionQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: appointments-completion-queue-${self:provider.stage}
        
    EventBusToSqsRule:
      Type: AWS::Events::Rule
      Properties:
        EventBusName: { "Ref": "AppointmentEventBus" }
        EventPattern:
          source:
            - "appointment.processor"
        Targets:
          - Arn: { "Fn::GetAtt": ["AppointmentsCompletionQueue", "Arn"] }
            Id: "CompletionQueueTarget"
            
    EventBridgeToSqsPolicy:
      Type: AWS::SQS::QueuePolicy
      Properties:
        Queues:
          - Ref: AppointmentsCompletionQueue
        PolicyDocument:
          Statement:
            - Effect: Allow
              Principal:
                Service: events.amazonaws.com
              Action: sqs:SendMessage
              Resource: { "Fn::GetAtt": ["AppointmentsCompletionQueue", "Arn"] }

// ===== Directory: services/appointment-api/src/handlers =====

// createAppointment.ts
import { CreateAppointmentSchema } from '@core/application/dtos/AppointmentDtos';
import { lambdaHandlerWrapper } from '@infrastructure/common/LambdaHandlerWrapper';
import { container } from '@infrastructure/di/container';
import { CreateAppointmentUseCase } from '@core/application/use-cases/CreateAppointment';
import { validateAndParse } from '@core/common/utils/validation';

async function createAppointmentHandler(event: any) {
  const body = JSON.parse(event.body);
  
  // Usamos el nuevo wrapper de validación.
  // Si la validación falla, lanzará un AppError que será capturado por el lambdaHandlerWrapper.
  const dto = validateAndParse(CreateAppointmentSchema, body);

  const useCase = container.resolve<CreateAppointmentUseCase>('createAppointmentUseCase');
  const result = await useCase.execute(dto);

  return {
    statusCode: 202, // Accepted
    body: result,
  };
}

export const handler = lambdaHandlerWrapper(createAppointmentHandler);// listAppointments.ts
import { ListAppointmentsRequestSchema } from '@core/application/dtos/AppointmentDtos';
import { lambdaHandlerWrapper } from '@infrastructure/common/LambdaHandlerWrapper';
import { container } from '@infrastructure/di/container';
import { ListAppointmentsUseCase } from '@core/application/use-cases/ListAppointments';
import { validateAndParse } from '@core/common/utils/validation'; // [!code ++]

/**
 * @description Manejador de Lambda para listar citas por insuredId.
 */
async function listAppointmentsHandler(event: any) {
  // Extraer parámetros de la ruta y validarlos con nuestra función estandarizada
  const { insuredId } = validateAndParse(ListAppointmentsRequestSchema, event.pathParameters); // [!code ++]
  // const { insuredId } = ListAppointmentsRequestSchema.parse(event.pathParameters); // [!code --]

  // Resolver la dependencia del caso de uso
  const useCase = container.resolve<ListAppointmentsUseCase>('listAppointmentsUseCase');
  
  // Ejecutar el caso de uso
  const result = await useCase.execute(insuredId);
  
  // Retornar la respuesta exitosa
  return {
    statusCode: 200,
    body: result,
  };
}

export const handler = lambdaHandlerWrapper(listAppointmentsHandler);// updateAppointmentStatus.ts
import { UpdateAppointmentStatusEventSchema } from '@core/application/dtos/AppointmentDtos';
import { UpdateAppointmentStatusUseCase } from '@core/application/use-cases/UpdateAppointmentStatus';
import { container } from '@infrastructure/di/container';
import { validateAndParse } from '@core/common/utils/validation'; // [!code ++]

export const handler = async (event: any): Promise<void> => {
  console.log('Received SQS event for status update:', JSON.stringify(event, null, 2));
  const useCase = container.resolve<UpdateAppointmentStatusUseCase>('updateAppointmentStatusUseCase');

  for (const record of event.Records) {
    try {
      const body = JSON.parse(record.body);
      // El cuerpo del mensaje de SQS contiene el evento completo de EventBridge.
      // El payload que nos interesa está en la propiedad 'detail'.
      const eventDetail = body.detail;
      
      // 1. Validar el detalle del evento usando nuestra función estandarizada
      const validatedEvent = validateAndParse(UpdateAppointmentStatusEventSchema, eventDetail); // [!code ++]
      // const validatedEvent = UpdateAppointmentStatusEventSchema.parse(eventDetail); // [!code --]

      // 2. Ejecutar el caso de uso con los datos validados
      await useCase.execute({
        appointmentId: validatedEvent.appointmentId,
        insuredId: validatedEvent.insuredId,
      });
    } catch (error) {
      console.error('Failed to process status update record:', record.body, error);
      // Lanzar el error para que SQS pueda gestionar los reintentos
      throw error;
    }
  }
};

// ===== Directory: services/appointment-processor =====

// serverless.yml
service: appointment-processor

provider:
  name: aws
  runtime: nodejs20.x
  region: ${opt:region, 'us-east-2'}
  stage: ${opt:stage, 'dev'}
  profile: ${opt:profile, 'aivoxia'}
  # Añadimos tags que se aplicarán a todos los recursos de la stack
  tags:
    app-id: test-medical-appoinments
    app-center-cost: test-medical-appoinments
    app-env: test
  environment:
    EVENT_BUS_NAME: appointment-event-bus-${self:provider.stage}
    # Estas variables deben ser configuradas de forma segura (ej. SSM Parameter Store o .env)
    #RDS_HOST: ${env:RDS_HOST}
    #RDS_USER: ${env:RDS_USER}
    #RDS_PASSWORD: ${env:RDS_PASSWORD}
    #RDS_DATABASE: ${env:RDS_DATABASE}

plugins:
  - serverless-esbuild

package:
  individually: true

custom:
  esbuild:
    bundle: true
    minify: false
    sourcemap: true
    packager: pnpm

functions:
  processPE:
    # Apuntamos al nuevo handler para Perú
    handler: src/handlers/processPE.handler
    events:
      - sqs:
          arn:
            Fn::Join:
              - ":"
              - - "arn:aws:sqs"
                - ${self:provider.region}
                - { Ref: "AWS::AccountId" }
                - "appointments-queue-pe-${self:provider.stage}"

  processCL:
    # Apuntamos al nuevo handler para Chile
    handler: src/handlers/processCL.handler
    events:
      - sqs:
          arn:
            Fn::Join:
              - ":"
              - - "arn:aws:sqs"
                - ${self:provider.region}
                - { Ref: "AWS::AccountId" }
                - "appointments-queue-cl-${self:provider.stage}"

# NOTA: En un proyecto real, se definirían aquí los permisos IAM explícitos
# para que los lambdas puedan acceder a SQS, RDS (VPC) y EventBridge.

// ===== Directory: services/appointment-processor/src/handlers =====

// processCL.ts
import { SnsAppointmentEventSchema } from '@core/application/dtos/AppointmentDtos';
import { ProcessAppointmentCLUseCase } from '@core/application/use-cases/ProcessAppointmentCL';
import { container } from '@infrastructure/di/container';
import { validateAndParse } from '@core/common/utils/validation';

export const handler = async (event: any): Promise<void> => {
  console.log('Received SQS event for CL:', JSON.stringify(event, null, 2));
  const useCase = container.resolve<ProcessAppointmentCLUseCase>('processAppointmentCLUseCase');

  for (const record of event.Records) {
    try {
      const body = JSON.parse(record.body);
      const appointmentEvent = validateAndParse(SnsAppointmentEventSchema, body);
      await useCase.execute(appointmentEvent);
    } catch (error) {
      console.error('Failed to process CL record:', record.body, error);
      throw error;
    }
  }
};// processPE.ts
import { SnsAppointmentEventSchema } from '@core/application/dtos/AppointmentDtos';
import { ProcessAppointmentPEUseCase } from '@core/application/use-cases/ProcessAppointmentPE';
import { container } from '@infrastructure/di/container';
import { validateAndParse } from '@core/common/utils/validation';

export const handler = async (event: any): Promise<void> => {
  console.log('Received SQS event for PE:', JSON.stringify(event, null, 2));
  const useCase = container.resolve<ProcessAppointmentPEUseCase>('processAppointmentPEUseCase');

  for (const record of event.Records) {
    try {
      const body = JSON.parse(record.body);
      const appointmentEvent = validateAndParse(SnsAppointmentEventSchema, body);
      await useCase.execute(appointmentEvent);
    } catch (error) {
      console.error('Failed to process PE record:', record.body, error);
      throw error;
    }
  }
};

// ===== Directory: . =====

// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["es2022"],
    "declaration": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "composite": true,
    "baseUrl": ".",
    "paths": {
      "@core/*": ["packages/core/src/*"],
      "@infrastructure/*": ["packages/infrastructure/src/*"]
    }
  }
}