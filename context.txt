// ===== Directory: . =====

// .gitignore
node_modules
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/packages'],
  moduleNameMapper: {
    '^@core/(.*)$': '<rootDir>/packages/core/src/$1',
    '^@infrastructure/(.*)$': '<rootDir>/packages/infrastructure/src/$1',
  },
};// package.json
{
  "name": "test-medical-appointments",
  "version": "1.0.0",
  "private": true,
  "description": "Backend for Medical Appointment Scheduling",
  "scripts": {
    "context": "node scripts/generate-context.js",
    "build": "tsc --build",
    "test": "jest",
    "test:watch": "jest --watch",
    "deploy:api": "cd services/appointment-api && pnpm sls deploy --verbose",
    "offline:api": "cd services/appointment-api && pnpm sls offline start",
    "lint": "eslint . --ext .ts"
  },
  "devDependencies": {
    "@types/jest": "^30.0.0",
    "@types/node": "^24.3.0",
    "esbuild": "^0.25.9",
    "eslint": "^9.33.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "jest": "^30.0.5",
    "prettier": "^3.6.2",
    "serverless": "^4.18.0",
    "serverless-dynamodb-local": "^0.2.40",
    "serverless-esbuild": "^1.55.1",
    "serverless-offline": "^14.4.0",
    "serverless-offline-sns": "^0.78.1",
    "serverless-offline-sqs": "^8.0.0",
    "ts-jest": "^29.4.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.2"
  },
  "pnpm": {
    "approvedBuildScripts": [
      "esbuild",
      "serverless"
    ]
  }
}

// ===== Directory: packages/core =====

// package.json
{
  "name": "@core",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "dependencies": {
    "zod": "^4.0.17"
  }
}

// ===== Directory: packages/core/src/application/dtos =====

// AppointmentDtos.ts
import { z } from 'zod';
import { AppointmentSchema } from '../../domain/entities/Appointment';

export const CreateAppointmentSchema = z.object({
  insuredId: z.string().regex(/^[0-9]{5}$/, "El insuredId debe ser de 5 dígitos numéricos."),
  scheduleId: z.number().int().positive(),
  countryISO: z.enum(['PE', 'CL']),
});
export type CreateAppointmentDto = z.infer<typeof CreateAppointmentSchema>;

export const ListAppointmentsRequestSchema = z.object({
  insuredId: z.string().regex(/^[0-9]{5}$/, "El insuredId debe ser de 5 dígitos numéricos."),
});
export type ListAppointmentsRequestDto = z.infer<typeof ListAppointmentsRequestSchema>;

export const AppointmentResponseSchema = AppointmentSchema;
export type AppointmentResponseDto = z.infer<typeof AppointmentResponseSchema>;

export const SnsAppointmentEventSchema = z.object({
  appointmentId: z.string().uuid(),
  insuredId: z.string(),
  scheduleId: z.number(),
  countryISO: z.enum(['PE', 'CL']),
  createdAt: z.string().datetime(),
});
export type SnsAppointmentEventDto = z.infer<typeof SnsAppointmentEventSchema>;

export const UpdateAppointmentStatusEventSchema = z.object({
  appointmentId: z.string().uuid(),
  insuredId: z.string(),
  status: z.literal('PROCESSED'),
});

// ===== Directory: packages/core/src/application/use-cases =====

// CreateAppointment.ts
import { AppointmentEntity } from '../../domain/entities/Appointment';
import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';
import { IEventPublisher } from '../../domain/ports/IEventPublisher';
import { CreateAppointmentDto, AppointmentResponseDto } from '../dtos/AppointmentDtos';

export class CreateAppointmentUseCase {
  constructor(
    private readonly appointmentRepository: IAppointmentRepository,
    private readonly eventPublisher: IEventPublisher,
  ) {}

  async execute(dto: CreateAppointmentDto): Promise<AppointmentResponseDto> {
    const appointmentEntity = AppointmentEntity.create(dto);
    const appointment = appointmentEntity.values;

    await this.appointmentRepository.save(appointment);

    await this.eventPublisher.publish('AppointmentRequested', {
      appointmentId: appointment.appointmentId,
      insuredId: appointment.insuredId,
      scheduleId: appointment.scheduleId,
      countryISO: appointment.countryISO,
      createdAt: appointment.createdAt,
    }, {
      countryISO: {
        DataType: 'String',
        StringValue: appointment.countryISO,
      }
    });
    
    return appointment;
  }
}// ListAppointments.ts
import { Appointment } from '../../domain/entities/Appointment';
import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';

/**
 * @description Caso de uso para listar citas médicas por el ID del asegurado.
 */
export class ListAppointmentsUseCase {
  /**
   * @param appointmentRepository El repositorio para acceder a los datos de las citas.
   */
  constructor(
    private readonly appointmentRepository: IAppointmentRepository
  ) {}

  /**
   * Ejecuta el caso de uso.
   * @param insuredId El ID del asegurado.
   * @returns Una promesa que se resuelve con un arreglo de citas.
   */
  async execute(insuredId: string): Promise<Appointment[]> {
    return this.appointmentRepository.findByInsuredId(insuredId);
  }
}// ProcessAppointment.ts
import { SnsAppointmentEventDto } from '../dtos/AppointmentDtos';
import { IConfirmationPublisher } from '../../domain/ports/IConfirmationPublisher';
import { Appointment } from '../../domain/entities/Appointment';

// Creamos una interfaz simple para el repositorio de RDS en la capa de aplicación
// para no depender directamente de la implementación de infra.
export interface IAppointmentRdsRepository {
  save(appointment: Appointment): Promise<void>;
}

/**
 * @description Caso de uso para procesar una cita, guardarla en la base de datos
 * secundaria (RDS) y publicar un evento de confirmación.
 */
export class ProcessAppointmentUseCase {
  constructor(
    private readonly rdsRepository: IAppointmentRdsRepository,
    private readonly confirmationPublisher: IConfirmationPublisher
  ) {}

  /**
   * Ejecuta el caso de uso.
   * @param appointmentEvent El DTO del evento recibido de SNS.
   */
  async execute(appointmentEvent: SnsAppointmentEventDto): Promise<void> {
    // 1. Reconstruir la entidad Appointment para la persistencia
    const appointmentToSave: Appointment = {
      ...appointmentEvent,
      status: 'PENDING', // El estado inicial se guarda en RDS
      updatedAt: new Date(appointmentEvent.createdAt).toISOString(),
    };

    // 2. Guardar en la base de datos RDS
    await this.rdsRepository.save(appointmentToSave);

    // 3. Publicar evento de confirmación
    await this.confirmationPublisher.publish({
      appointmentId: appointmentToSave.appointmentId,
      insuredId: appointmentToSave.insuredId,
      status: 'PROCESSED',
    });
  }
}// UpdateAppointmentStatus.ts
import { AppointmentEntity } from '../../domain/entities/Appointment';
import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';
import { AppError, ErrorCode, HttpStatusCode } from '../../common/errors/AppError';

interface UpdateAppointmentStatusDto {
  appointmentId: string;
  insuredId: string;
}

/**
 * @description Caso de uso para actualizar el estado de una cita a 'COMPLETED'.
 */
export class UpdateAppointmentStatusUseCase {
  constructor(
    private readonly appointmentRepository: IAppointmentRepository
  ) {}

  /**
   * Ejecuta el caso de uso.
   * @param dto El DTO con los identificadores de la cita.
   */
  async execute(dto: UpdateAppointmentStatusDto): Promise<void> {
    const { appointmentId, insuredId } = dto;

    // 1. Encontrar la cita existente
    const existingAppointment = await this.appointmentRepository.findById({ appointmentId, insuredId });

    if (!existingAppointment) {
      // En un sistema real, podríamos mover este mensaje a una DLQ o registrar una alerta.
      // Por ahora, lanzamos un error para indicar que la cita no fue encontrada.
      throw new AppError(
        `Appointment with ID ${appointmentId} not found.`,
        ErrorCode.NotFound,
        HttpStatusCode.NOT_FOUND
      );
    }
    
    // 2. Rehidratar la entidad de dominio
    const appointmentEntity = new AppointmentEntity(existingAppointment);

    // 3. Ejecutar la lógica de dominio para completar la cita
    appointmentEntity.complete();

    // 4. Persistir los cambios usando el repositorio
    await this.appointmentRepository.update(appointmentEntity.values);
    
    console.log(`Appointment ${appointmentId} status updated to COMPLETED.`);
  }
}

// ===== Directory: packages/core/src/common/errors =====

// AppError.ts
// (Reutilizar el código de AppError y sus subclases del proyecto anterior)
export enum ErrorCode {
	BadRequest = "BAD_REQUEST",
	NotFound = "NOT_FOUND",
	ServerError = "SERVER_ERROR",
}

export enum HttpStatusCode {
	BAD_REQUEST = 400,
	NOT_FOUND = 404,
	INTERNAL_SERVER_ERROR = 500,
}

export class AppError extends Error {
	constructor(
		message: string,
		public errorCode: ErrorCode,
		public statusCode: HttpStatusCode,
		public errors?: object[],
	) {
		super(message);
	}
}

// ===== Directory: packages/core/src/domain/entities =====

// Appointment.ts
import { z } from 'zod';

export const AppointmentSchema = z.object({
  appointmentId: z.string().uuid(),
  insuredId: z.string().length(5),
  scheduleId: z.number().int().positive(),
  countryISO: z.enum(['PE', 'CL']),
  status: z.enum(['PENDING', 'COMPLETED', 'FAILED']),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});

export type Appointment = z.infer<typeof AppointmentSchema>;

export class AppointmentEntity {
  private props: Appointment;

  constructor(props: Appointment) {
    this.props = { ...props };
  }

  static create(props: Omit<Appointment, 'appointmentId' | 'status' | 'createdAt' | 'updatedAt'>): AppointmentEntity {
    const now = new Date().toISOString();
    return new AppointmentEntity({
      ...props,
      appointmentId: crypto.randomUUID(),
      status: 'PENDING',
      createdAt: now,
      updatedAt: now,
    });
  }

  get values(): Appointment {
    return this.props;
  }

  complete(): void {
    if (this.props.status !== 'PENDING') {
      // Aquí podrías lanzar un DomainError si fuera necesario
      return;
    }
    this.props.status = 'COMPLETED';
    this.props.updatedAt = new Date().toISOString();
  }
}

// ===== Directory: packages/core/src/domain/ports =====

// IConfirmationPublisher.ts
/**
 * @description Interfaz para un publicador de eventos de confirmación de procesamiento.
 */
export interface IConfirmationPublisher {
  /**
   * Publica un evento de confirmación.
   * @param eventDetail El payload del evento.
   */
  publish(eventDetail: Record<string, any>): Promise<void>;
}// IEventPublisher.ts
export interface IEventPublisher {
  publish(topic: string, event: Record<string, any>, attributes?: Record<string, any>): Promise<void>;
}

// ===== Directory: packages/core/src/domain/ports/repositories =====

// IAppointmentRepository.ts
import { Appointment } from "../../entities/Appointment";

export interface IAppointmentRepository {
  save(appointment: Appointment): Promise<void>;
  findById(keys: { appointmentId: string, insuredId: string }): Promise<Appointment | null>; // [!code ++]
  update(appointment: Appointment): Promise<void>; // [!code ++]
  findByInsuredId(insuredId: string): Promise<Appointment[]>; // [!code ++]
}

// ===== Directory: packages/core =====

// tsconfig.json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*"]
}

// ===== Directory: packages/infrastructure =====

// package.json
{
  "name": "@infrastructure",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.583.0",
    "@aws-sdk/client-eventbridge": "^3.583.0",
    "@aws-sdk/client-sns": "^3.583.0",
    "@aws-sdk/util-dynamodb": "^3.583.0",
    "awilix": "^10.0.1",
    "mysql2": "^3.9.7",
    "zod": "^4.0.17"
  },
  "devDependencies": {
    "@types/mysql2": "github:types/mysql2"
  }
}

// ===== Directory: packages/infrastructure/src/common =====

// LambdaHandlerWrapper.ts
import { AppError } from '../../../core/src/common/AppError';
import { ZodError } from 'zod';

export const lambdaHandlerWrapper = (handler: Function) => async (event: any, context: any) => {
  try {
    console.log('Request Event:', JSON.stringify(event, null, 2));
    const result = await handler(event, context);

    return {
      statusCode: result.statusCode || 200,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(result.body),
    };
  } catch (error: any) {
    if (error instanceof ZodError) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          code: 'VALIDATION_ERROR',
          message: 'La solicitud contiene datos inválidos.',
          errors: error.errors,
        }),
      };
    }

    if (error instanceof AppError) {
      return {
        statusCode: error.statusCode,
        body: JSON.stringify({
          code: error.errorCode,
          message: error.message,
          errors: error.errors || [],
        }),
      };
    }
    
    console.error("UNEXPECTED_ERROR", error);
    return {
      statusCode: 500,
      body: JSON.stringify({
        code: 'SERVER_ERROR',
        message: 'Ocurrió un error inesperado.',
      }),
    };
  }
};

// ===== Directory: packages/infrastructure/src/di =====

// container.ts
import { createContainer, asClass, InjectionMode } from 'awilix';
import { CreateAppointmentUseCase } from '@core/application/use-cases/CreateAppointment';
import { ListAppointmentsUseCase } from '@core/application/use-cases/ListAppointments';
import { UpdateAppointmentStatusUseCase } from '@core/application/use-cases/UpdateAppointmentStatus';
import { ProcessAppointmentUseCase } from '@core/application/use-cases/ProcessAppointment';
import { DynamoDbAppointmentRepository } from '../persistence/dynamodb/AppointmentRepository';
import { SnsEventPublisher } from '../messaging/SnsEventPublisher';
import { AppointmentRdsRepository } from '../persistence/rds/AppointmentRdsRepository';
import { EventBridgePublisher } from '../messaging/EventBridgePublisher';

const container = createContainer({
  injectionMode: InjectionMode.PROXY,
});

// Contenedor Centralizado para todos los servicios
container.register({
  // Repositorios
  appointmentRepository: asClass(DynamoDbAppointmentRepository).singleton(),
  rdsRepository: asClass(AppointmentRdsRepository).singleton(),
  
  // Publicadores de Eventos
  eventPublisher: asClass(SnsEventPublisher).singleton(),
  confirmationPublisher: asClass(EventBridgePublisher).singleton(),

  // Casos de Uso
  createAppointmentUseCase: asClass(CreateAppointmentUseCase).singleton(),
  listAppointmentsUseCase: asClass(ListAppointmentsUseCase).singleton(),
  updateAppointmentStatusUseCase: asClass(UpdateAppointmentStatusUseCase).singleton(),
  processAppointmentUseCase: asClass(ProcessAppointmentUseCase).singleton(),
});

export { container };

// ===== Directory: packages/infrastructure/src/messaging =====

// EventBridgePublisher.ts
import { EventBridgeClient, PutEventsCommand } from '@aws-sdk/client-eventbridge';
import { IConfirmationPublisher } from '@core/domain/ports/IConfirmationPublisher';

/**
 * @description Publicador de eventos que utiliza AWS EventBridge.
 */
export class EventBridgePublisher implements IConfirmationPublisher {
  private readonly eventBridgeClient: EventBridgeClient;
  private readonly eventBusName = process.env.EVENT_BUS_NAME!;
  private readonly eventSource = 'appointment.processor';
  private readonly eventDetailType = 'AppointmentProcessed';

  constructor() {
    this.eventBridgeClient = new EventBridgeClient({
      region: process.env.AWS_REGION || 'us-east-1',
    });
  }

  /**
   * Publica un evento de confirmación en el bus de EventBridge.
   * @param detail El payload del evento.
   */
  async publish(detail: Record<string, any>): Promise<void> {
    const command = new PutEventsCommand({
      Entries: [
        {
          Source: this.eventSource,
          DetailType: this.eventDetailType,
          Detail: JSON.stringify(detail),
          EventBusName: this.eventBusName,
        },
      ],
    });

    try {
      await this.eventBridgeClient.send(command);
      console.log(`Event published successfully to EventBridge bus: ${this.eventBusName}`);
    } catch (error) {
      console.error('Error publishing event to EventBridge:', error);
      throw error;
    }
  }
}// SnsEventPublisher.ts
import { SNSClient, PublishCommand, MessageAttributeValue } from '@aws-sdk/client-sns';
import { IEventPublisher } from '@core/domain/ports/IEventPublisher';

/**
 * @description Implementación de IEventPublisher que publica eventos en un tópico de AWS SNS.
 */
export class SnsEventPublisher implements IEventPublisher {
  private readonly snsClient: SNSClient;
  private readonly topicArn = process.env.SNS_TOPIC_APPOINTMENTS_ARN!;

  constructor() {
    this.snsClient = new SNSClient({
      region: process.env.AWS_REGION || 'us-east-1',
      endpoint: process.env.IS_OFFLINE ? 'http://localhost:4002' : undefined,
    });
  }

  /**
   * Publica un evento en el tópico SNS configurado.
   * @param topic El nombre lógico del tema (no se usa directamente, se usa el ARN de la variable de entorno).
   * @param event El objeto del evento a publicar.
   * @param attributes Atributos del mensaje para filtrado en SNS.
   */
  async publish(topic: string, event: Record<string, any>, attributes?: Record<string, MessageAttributeValue>): Promise<void> {
    const command = new PublishCommand({
      TopicArn: this.topicArn,
      Message: JSON.stringify(event),
      MessageAttributes: attributes,
    });

    try {
      await this.snsClient.send(command);
      console.log(`Event published successfully to SNS topic: ${this.topicArn}`);
    } catch (error) {
      console.error('Error publishing event to SNS:', error);
      // En un caso real, aquí se podría implementar una estrategia de reintentos o "dead-letter queue".
      throw error;
    }
  }
}

// ===== Directory: packages/infrastructure/src/persistence/dynamodb =====

// AppointmentRepository.ts
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand, QueryCommand, GetCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { Appointment } from '@core/domain/entities/Appointment';

export class DynamoDbAppointmentRepository implements IAppointmentRepository {
  private readonly docClient: DynamoDBDocumentClient;
  private readonly tableName = process.env.DYNAMODB_TABLE_APPOINTMENTS!;

  constructor() {
    const client = new DynamoDBClient({
      endpoint: process.env.IS_OFFLINE ? 'http://localhost:8000' : undefined,
    });
    this.docClient = DynamoDBDocumentClient.from(client);
  }

  async save(appointment: Appointment): Promise<void> {
    const command = new PutCommand({
      TableName: this.tableName,
      Item: appointment,
    });
    await this.docClient.send(command);
  }

  async findById(keys: { appointmentId: string; insuredId: string }): Promise<Appointment | null> {
    const command = new GetCommand({
      TableName: this.tableName,
      Key: {
        insuredId: keys.insuredId,
        appointmentId: keys.appointmentId,
      },
    });
    const { Item } = await this.docClient.send(command);
    return (Item as Appointment) || null;
  }

  async update(appointment: Appointment): Promise<void> {
    const command = new UpdateCommand({
      TableName: this.tableName,
      Key: {
        insuredId: appointment.insuredId,
        appointmentId: appointment.appointmentId,
      },
      UpdateExpression: 'set #status = :status, updatedAt = :updatedAt',
      ExpressionAttributeNames: {
        '#status': 'status', // 'status' es una palabra reservada en DynamoDB
      },
      ExpressionAttributeValues: {
        ':status': appointment.status,
        ':updatedAt': appointment.updatedAt,
      },
    });
    await this.docClient.send(command);
  }
  
  async findByInsuredId(insuredId: string): Promise<Appointment[]> {
    const command = new QueryCommand({
      TableName: this.tableName,
      KeyConditionExpression: 'insuredId = :insuredId',
      ExpressionAttributeValues: {
        ':insuredId': insuredId,
      },
    });

    const { Items } = await this.docClient.send(command);
    return (Items as Appointment[]) || [];
  }
}

// ===== Directory: packages/infrastructure/src/persistence/rds =====

// AppointmentRdsRepository.ts
import { createPool, Pool } from 'mysql2/promise';
import { Appointment } from '@core/domain/entities/Appointment';
import { IAppointmentRdsRepository } from '@core/application/use-cases/ProcessAppointment';

/**
 * @description Repositorio para manejar la persistencia de citas en una base de datos RDS (MySQL).
 * Asume una tabla `appointments` con la siguiente estructura (o similar):
 * CREATE TABLE appointments (
 * appointment_id VARCHAR(36) PRIMARY KEY,
 * insured_id VARCHAR(5) NOT NULL,
 * schedule_id INT NOT NULL,
 * country_iso VARCHAR(2) NOT NULL,
 * status VARCHAR(10) NOT NULL,
 * created_at TIMESTAMP NOT NULL
 * );
 */
export class AppointmentRdsRepository implements IAppointmentRdsRepository {
  private pool: Pool;

  constructor() {
    this.pool = createPool({
      host: process.env.RDS_HOST,
      user: process.env.RDS_USER,
      password: process.env.RDS_PASSWORD,
      database: process.env.RDS_DATABASE,
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0,
    });
  }

  /**
   * Guarda una cita en la base de datos MySQL.
   * @param appointment El objeto de la cita a persistir.
   */
  async save(appointment: Appointment): Promise<void> {
    const sql = `
      INSERT INTO appointments (appointment_id, insured_id, schedule_id, country_iso, status, created_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `;
    try {
      await this.pool.execute(sql, [
        appointment.appointmentId,
        appointment.insuredId,
        appointment.scheduleId,
        appointment.countryISO,
        appointment.status,
        new Date(appointment.createdAt),
      ]);
      console.log(`Appointment ${appointment.appointmentId} saved to RDS.`);
    } catch (error) {
      console.error('Error saving appointment to RDS:', error);
      throw new Error('Failed to save appointment to RDS.');
    }
  }
}

// ===== Directory: . =====

// pnpm-workspace.yaml
# pnpm-workspace.yaml
packages:
  # Todos los paquetes en la carpeta 'packages'
  - 'packages/*'
  # Todos los servicios en la carpeta 'services'
  - 'services/*'// README.md
# test-medical-appointments


// ===== Directory: services/appointment-api =====

// serverless.yml
service: appointment-api

provider:
  name: aws
  runtime: nodejs20.x
  region: us-east-1
  stage: ${opt:stage, 'dev'}
  environment:
    DYNAMODB_TABLE_APPOINTMENTS: ${self:custom.tableName}
    SNS_TOPIC_APPOINTMENTS_ARN: { "Ref": "AppointmentsTopic" }

plugins:
  - serverless-esbuild
  - serverless-offline
  - serverless-dynamodb-local

package:
  individually: true

custom:
  tableName: appointments-table-${self:provider.stage}
  esbuild:
    bundle: true
    minify: false
    sourcemap: true
    packager: pnpm
  dynamodb:
    start:
      port: 8000
      inMemory: true
      migrate: true

functions:
  createAppointment:
    handler: src/handlers/createAppointment.handler
    events:
      - httpApi:
          path: /appointments
          method: post
  
  listAppointments:
    handler: src/handlers/listAppointments.handler
    events:
      - httpApi:
          path: /appointments/{insuredId}
          method: get
          
  updateAppointmentStatus:
    handler: src/handlers/updateAppointmentStatus.handler
    events:
      - sqs:
          arn:
            Fn::GetAtt: [AppointmentsCompletionQueue, Arn]

resources:
  Resources:
    AppointmentsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tableName}
        AttributeDefinitions:
          - AttributeName: insuredId
            AttributeType: S
          - AttributeName: appointmentId
            AttributeType: S
        KeySchema:
          - AttributeName: insuredId
            KeyType: HASH
          - AttributeName: appointmentId
            KeyType: RANGE
        BillingMode: PAY_PER_REQUEST
    
    AppointmentsTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: appointments-topic-${self:provider.stage}

    AppointmentsQueuePE:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: appointments-queue-pe-${self:provider.stage}

    AppointmentsQueueCL:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: appointments-queue-cl-${self:provider.stage}

    SnsSubscriptionPE:
      Type: AWS::SNS::Subscription
      Properties:
        Protocol: sqs
        Endpoint: { "Fn::GetAtt": ["AppointmentsQueuePE", "Arn"] }
        TopicArn: { "Ref": "AppointmentsTopic" }
        FilterPolicy:
          countryISO: ["PE"]
        RawMessageDelivery: "true"

    SnsSubscriptionCL:
      Type: AWS::SNS::Subscription
      Properties:
        Protocol: sqs
        Endpoint: { "Fn::GetAtt": ["AppointmentsQueueCL", "Arn"] }
        TopicArn: { "Ref": "AppointmentsTopic" }
        FilterPolicy:
          countryISO: ["CL"]
        RawMessageDelivery: "true"

    SqsPolicy:
      Type: AWS::SQS::QueuePolicy
      Properties:
        Queues:
          - { "Ref": "AppointmentsQueuePE" }
          - { "Ref": "AppointmentsQueueCL" }
        PolicyDocument:
          Statement:
            - Effect: "Allow"
              Principal:
                Service: "sns.amazonaws.com"
              Action: "sqs:SendMessage"
              Resource: "*"
              Condition:
                ArnEquals:
                  aws:SourceArn: { "Ref": "AppointmentsTopic" }
    
    AppointmentEventBus:
      Type: AWS::Events::EventBus
      Properties:
        Name: appointment-event-bus-${self:provider.stage}
        
    AppointmentsCompletionQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: appointments-completion-queue-${self:provider.stage}
        
    EventBusToSqsRule:
      Type: AWS::Events::Rule
      Properties:
        EventBusName: { "Ref": "AppointmentEventBus" }
        EventPattern:
          source:
            - "appointment.processor"
        Targets:
          - Arn: { "Fn::GetAtt": ["AppointmentsCompletionQueue", "Arn"] }
            Id: "CompletionQueueTarget"
            
    EventBridgeToSqsPolicy:
      Type: AWS::SQS::QueuePolicy
      Properties:
        Queues:
          - Ref: AppointmentsCompletionQueue
        PolicyDocument:
          Statement:
            - Effect: Allow
              Principal:
                Service: events.amazonaws.com
              Action: sqs:SendMessage
              Resource: { "Fn::GetAtt": ["AppointmentsCompletionQueue", "Arn"] }

// ===== Directory: services/appointment-api/src =====

// createAppointment.ts
import { CreateAppointmentSchema } from '@core/application/dtos/AppointmentDtos';
import { lambdaHandlerWrapper } from '@infrastructure/common/LambdaHandlerWrapper';
// Lógica para inicializar el contenedor de DI (Awilix)
import { container } from '@infrastructure/dependency-injection/container';

async function createAppointmentHandler(event: any) {
  const body = JSON.parse(event.body);
  const dto = CreateAppointmentSchema.parse(body);

  const useCase = container.resolve('createAppointmentUseCase');
  const result = await useCase.execute(dto);

  return {
    statusCode: 202, // Accepted
    body: result,
  };
}

export const handler = lambdaHandlerWrapper(createAppointmentHandler);// listAppointments.ts
import { ListAppointmentsRequestSchema } from '@core/application/dtos/AppointmentDtos';
import { lambdaHandlerWrapper } from '@infrastructure/common/LambdaHandlerWrapper';
import { container } from '@infrastructure/di/container';
import { ListAppointmentsUseCase } from '@core/application/use-cases/ListAppointments';

/**
 * @description Manejador de Lambda para listar citas por insuredId.
 */
async function listAppointmentsHandler(event: any) {
  // Extraer parámetros de la ruta y validarlos
  const { insuredId } = ListAppointmentsRequestSchema.parse(event.pathParameters);

  // Resolver la dependencia del caso de uso
  const useCase = container.resolve<ListAppointmentsUseCase>('listAppointmentsUseCase');
  
  // Ejecutar el caso de uso
  const result = await useCase.execute(insuredId);

  // Retornar la respuesta exitosa
  return {
    statusCode: 200,
    body: result,
  };
}

export const handler = lambdaHandlerWrapper(listAppointmentsHandler);// updateAppointmentStatus.ts
import { UpdateAppointmentStatusEventSchema } from '@core/application/dtos/AppointmentDtos';
import { UpdateAppointmentStatusUseCase } from '@core/application/use-cases/UpdateAppointmentStatus';
import { container } from '@infrastructure/di/container';

export const handler = async (event: any): Promise<void> => {
  console.log('Received SQS event for status update:', JSON.stringify(event, null, 2));

  const useCase = container.resolve<UpdateAppointmentStatusUseCase>('updateAppointmentStatusUseCase');

  for (const record of event.Records) {
    try {
      const body = JSON.parse(record.body);
      
      // El cuerpo del mensaje de SQS contiene el evento completo de EventBridge.
      // El payload que nos interesa está en la propiedad 'detail'.
      const eventDetail = body.detail;

      // 1. Validar el detalle del evento
      const validatedEvent = UpdateAppointmentStatusEventSchema.parse(eventDetail);

      // 2. Ejecutar el caso de uso con los datos validados
      await useCase.execute({
        appointmentId: validatedEvent.appointmentId,
        insuredId: validatedEvent.insuredId,
      });

    } catch (error) {
      console.error('Failed to process status update record:', record.body, error);
      // Lanzar el error para que SQS pueda gestionar los reintentos
      throw error;
    }
  }
};

// ===== Directory: services/appointment-processor =====

// serverless.yml
service: appointment-processor

provider:
  name: aws
  runtime: nodejs20.x
  region: us-east-1
  stage: ${opt:stage, 'dev'}
  environment:
    EVENT_BUS_NAME: appointment-event-bus-${self:provider.stage}
    # Estas variables deben ser configuradas de forma segura (ej. SSM Parameter Store o .env)
    RDS_HOST: ${env:RDS_HOST}
    RDS_USER: ${env:RDS_USER}
    RDS_PASSWORD: ${env:RDS_PASSWORD}
    RDS_DATABASE: ${env:RDS_DATABASE}

plugins:
  - serverless-esbuild

package:
  individually: true

custom:
  esbuild:
    bundle: true
    minify: false
    sourcemap: true
    packager: pnpm

functions:
  processPE:
    handler: src/handlers/process.handler
    events:
      - sqs:
          arn:
            Fn::Join:
              - ":"
              - - "arn:aws:sqs"
                - ${self:provider.region}
                - { Ref: "AWS::AccountId" }
                - "appointments-queue-pe-${self:provider.stage}"

  processCL:
    handler: src/handlers/process.handler
    events:
      - sqs:
          arn:
            Fn::Join:
              - ":"
              - - "arn:aws:sqs"
                - ${self:provider.region}
                - { Ref: "AWS::AccountId" }
                - "appointments-queue-cl-${self:provider.stage}"

# NOTA: En un proyecto real, se definirían aquí los permisos IAM explícitos
# para que los lambdas puedan acceder a SQS, RDS (VPC) y EventBridge.

// ===== Directory: services/appointment-processor/src/handlers =====

// process.ts
import { SnsAppointmentEventSchema } from '@core/application/dtos/AppointmentDtos';
import { ProcessAppointmentUseCase } from '@core/application/use-cases/ProcessAppointment';
import { container } from '@infrastructure/di/container';

export const handler = async (event: any): Promise<void> => {
  console.log('Received SQS event:', JSON.stringify(event, null, 2));

  // Resolver el caso de uso desde el contenedor de DI centralizado
  const useCase = container.resolve<ProcessAppointmentUseCase>('processAppointmentUseCase');

  for (const record of event.Records) {
    try {
      const body = JSON.parse(record.body);
      
      // 1. Validar el payload del evento
      const appointmentEvent = SnsAppointmentEventSchema.parse(body);

      // 2. Ejecutar el caso de uso
      await useCase.execute(appointmentEvent);

    } catch (error) {
      console.error('Failed to process record:', record.body, error);
      throw error; 
    }
  }
};

// ===== Directory: . =====

// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["es2022"],
    "declaration": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "composite": true,
    "baseUrl": ".",
    "paths": {
      "@core/*": ["packages/core/src/*"],
      "@infrastructure/*": ["packages/infrastructure/src/*"]
    }
  }
}