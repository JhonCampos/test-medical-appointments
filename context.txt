// ===== Directory: . =====

// .gitignore
node_modules
// api.http 
# api.http
# Archivo para probar los endpoints del servicio appointment-api.
# Requiere la extensión "REST Client" en Visual Studio Code.

# --- Variables ---
# Define la URL base del servicio local iniciado con `sls offline`.
@host = http://localhost:3000

###
# ==============================================================================
# 1. Crear una nueva cita (POST /appointments)
# ==============================================================================
# Esta petición envía un payload para crear una cita médica para Perú.
# Haz clic en "Send Request" arriba de POST para ejecutarla.
POST {{host}}/appointments
Content-Type: application/json

{
  "insuredId": "12345",
  "scheduleId": 101,
  "countryISO": "PE"
}

###
# Ejemplo para crear una cita para Chile.
POST {{host}}/appointments
Content-Type: application/json

{
  "insuredId": "54321",
  "scheduleId": 202,
  "countryISO": "CL"
}

###
# Ejemplo de petición con datos inválidos (el insuredId no tiene 5 dígitos).
# Debería devolver un error 400 (Bad Request).
POST {{host}}/appointments
Content-Type: application/json

{
  "insuredId": "123",
  "scheduleId": 303,
  "countryISO": "PE"
}


###
# ==============================================================================
# 2. Listar citas por ID de asegurado (GET /appointments/{insuredId})
# ==============================================================================
# Reemplaza '12345' con el ID del asegurado que deseas consultar.
# Primero debes haber creado al menos una cita para este ID.
GET {{host}}/appointments/12345

###
# Ejemplo para consultar el otro asegurado.
GET {{host}}/appointments/54321

// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/packages/test'],
  moduleNameMapper: {
    '^@core/(.*)$': '<rootDir>/packages/core/src/$1',
    '^@infrastructure/(.*)$': '<rootDir>/packages/infrastructure/src/$1',
  },
};// package.json
{
  "name": "test-medical-appointments",
  "version": "1.0.0",
  "private": true,
  "description": "Backend for Medical Appointment Scheduling",
  "scripts": {
    "context": "node scripts/generate-context.js",
    "docs:generate": "ts-node scripts/generate-openapi.ts",
    "build": "tsc --build",
    "test": "jest",
    "test:watch": "jest --watch",
    "deploy:api": "cd services/appointment-api && sls deploy --verbose",
    "deploy:processor": "cd services/appointment-processor && sls deploy --verbose",
    "offline:api": "cd services/appointment-api && sls offline start",
    "lint": "eslint . --ext .ts"
  },
  "devDependencies": {
    "@types/jest": "^30.0.0",
    "@types/node": "^24.3.0",
    "@types/swagger-ui-express": "^4.1.8",
    "esbuild": "^0.25.9",
    "eslint": "^9.33.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "jest": "^30.0.5",
    "prettier": "^3.6.2",
    "serverless": "^4.18.0",
    "serverless-dynamodb-local": "^0.2.40",
    "serverless-esbuild": "^1.55.1",
    "serverless-offline": "^14.4.0",
    "serverless-offline-sns": "^0.78.1",
    "serverless-offline-sqs": "^8.0.0",
    "swagger-ui-express": "^5.0.1",
    "ts-jest": "^29.4.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.2",
    "yaml": "^2.8.1",
    "zod": "^4.0.17"
  },
  "pnpm": {
    "approvedBuildScripts": [
      "esbuild",
      "serverless"
    ]
  }
}

// ===== Directory: packages/core =====

// package.json
{
  "name": "@core",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "dependencies": {
    "zod": "^4.0.17"
  }
}

// ===== Directory: packages/core/src/application/dtos =====

// AppointmentDtos.ts
import { z } from 'zod/v4';

// Primero definimos el esquema de Appointment aquí para evitar importaciones circulares
export const AppointmentSchema = z.object({
  appointmentId: z.string(),
  insuredId: z.string().length(5),
  scheduleId: z.number().int().positive(),
  countryISO: z.enum(['PE', 'CL']),
  status: z.enum(['PENDING', 'COMPLETED', 'FAILED']),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});

export const CreateAppointmentSchema = z.object({
  insuredId: z.string().regex(/^[0-9]{5}$/, "El insuredId debe ser de 5 dígitos numéricos."),
  scheduleId: z.number().int().positive(),
  countryISO: z.enum(['PE', 'CL']),
});
export type CreateAppointmentDto = z.infer<typeof CreateAppointmentSchema>;

export const ListAppointmentsRequestSchema = z.object({
  insuredId: z.string().regex(/^[0-9]{5}$/, "El insuredId debe ser de 5 dígitos numéricos."),
});
export type ListAppointmentsRequestDto = z.infer<typeof ListAppointmentsRequestSchema>;

export const AppointmentResponseSchema = AppointmentSchema;
export type AppointmentResponseDto = z.infer<typeof AppointmentResponseSchema>;

export const SnsAppointmentEventSchema = z.object({
  appointmentId: z.string(),
  insuredId: z.string(),
  scheduleId: z.number(),
  countryISO: z.enum(['PE', 'CL']),
  createdAt: z.iso.datetime(),
});
export type SnsAppointmentEventDto = z.infer<typeof SnsAppointmentEventSchema>;

export const UpdateAppointmentStatusEventSchema = z.object({
  appointmentId: z.string(),
  insuredId: z.string(),
  status: z.literal('PROCESSED'),
});
export type UpdateAppointmentStatusEventDto = z.infer<typeof UpdateAppointmentStatusEventSchema>;

export const GetAppointmentRequestSchema = z.object({ 
  insuredId: z.string().regex(/^[0-9]{5}$/, "El insuredId debe ser de 5 dígitos numéricos."), // [!code ++]
  appointmentId: z.string().uuid("El appointmentId debe ser un UUID válido."), // [!code ++]
});
export type GetAppointmentRequestDto = z.infer<typeof GetAppointmentRequestSchema>; // [!code ++]


// ===== Directory: packages/core/src/application/use-cases =====

// CreateAppointment.ts
import { AppointmentEntity } from '../../domain/entities/Appointment';
import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';
import { IEventPublisher } from '../../domain/ports/IEventPublisher';
import { CreateAppointmentDto, AppointmentResponseDto } from '../dtos/AppointmentDtos';

export class CreateAppointmentUseCase {
  constructor(
    private readonly appointmentRepository: IAppointmentRepository,
    private readonly eventPublisher: IEventPublisher,
  ) {}

  async execute(dto: CreateAppointmentDto): Promise<AppointmentResponseDto> {
    const appointmentEntity = AppointmentEntity.create(dto);
    const appointment = appointmentEntity.values;

    await this.appointmentRepository.save(appointment);

    await this.eventPublisher.publish('AppointmentRequested', {
      appointmentId: appointment.appointmentId,
      insuredId: appointment.insuredId,
      scheduleId: appointment.scheduleId,
      countryISO: appointment.countryISO,
      createdAt: appointment.createdAt,
    }, {
      countryISO: {
        DataType: 'String',
        StringValue: appointment.countryISO,
      }
    });
    
    return appointment;
  }
}// GetAppointment.ts
// packages/core/src/application/use-cases/GetAppointment.ts

import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';
import { AppointmentResponseDto } from '../dtos/AppointmentDtos';
import { NotFoundError } from '../../common/errors/AppError';

interface GetAppointmentDto {
  insuredId: string;
  appointmentId: string;
}

/**
 * @description Caso de uso para obtener los detalles de una cita específica.
 */
export class GetAppointmentUseCase {
  /**
   * @param appointmentRepository El repositorio para acceder a los datos de las citas.
   */
  constructor(
    private readonly appointmentRepository: IAppointmentRepository
  ) {}

  /**
   * Ejecuta el caso de uso.
   * @param dto El DTO con los identificadores de la cita.
   * @returns Una promesa que se resuelve con los datos de la cita.
   * @throws {NotFoundError} Si la cita no se encuentra.
   */
  async execute(dto: GetAppointmentDto): Promise<AppointmentResponseDto> {
    const appointment = await this.appointmentRepository.findById({
      insuredId: dto.insuredId,
      appointmentId: dto.appointmentId,
    });

    if (!appointment) {
      throw new NotFoundError(`No se encontró la cita con ID ${dto.appointmentId}.`);
    }

    return appointment;
  }
}// ListAppointments.ts
import { Appointment } from '../../domain/entities/Appointment';
import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';

/**
 * @description Caso de uso para listar citas médicas por el ID del asegurado.
 */
export class ListAppointmentsUseCase {
  /**
   * @param appointmentRepository El repositorio para acceder a los datos de las citas.
   */
  constructor(
    private readonly appointmentRepository: IAppointmentRepository
  ) {}

  /**
   * Ejecuta el caso de uso.
   * @param insuredId El ID del asegurado.
   * @returns Una promesa que se resuelve con un arreglo de citas.
   */
  async execute(insuredId: string): Promise<Appointment[]> {
    return this.appointmentRepository.findByInsuredId(insuredId);
  }
}// ProcessAppointmentCL.ts
import { SnsAppointmentEventDto } from '../dtos/AppointmentDtos';
import { IConfirmationPublisher } from '../../domain/ports/IConfirmationPublisher';
import { Appointment } from '../../domain/entities/Appointment';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';

/**
 * @description Caso de uso para procesar una cita de CHILE.
 * Guarda en RDS y publica un evento de confirmación.
 */
export class ProcessAppointmentCLUseCase {
  constructor(
    private readonly countryRepository: IAppointmentCountryRepository,
    private readonly confirmationPublisher: IConfirmationPublisher
  ) {}

  /**
   * Ejecuta el caso de uso para Chile.
   * @param appointmentEvent El DTO del evento recibido de SNS.
   */
  async execute(appointmentEvent: SnsAppointmentEventDto): Promise<void> {
    const appointmentToSave: Appointment = {
      ...appointmentEvent,
      status: 'PENDING',
      updatedAt: new Date(appointmentEvent.createdAt).toISOString(),
    };
    
    // Aquí iría la futura lógica de negocio específica para Chile.
    console.log(`Executing Chile-specific appointment processing for ID: ${appointmentEvent.appointmentId}`);

    await this.countryRepository.save(appointmentToSave);

    await this.confirmationPublisher.publish({
      appointmentId: appointmentToSave.appointmentId,
      insuredId: appointmentToSave.insuredId,
      status: 'PROCESSED',
    });
  }
}// ProcessAppointmentPE.ts
import { SnsAppointmentEventDto } from '../dtos/AppointmentDtos';
import { IConfirmationPublisher } from '../../domain/ports/IConfirmationPublisher';
import { Appointment } from '../../domain/entities/Appointment';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';

/**
 * @description Caso de uso para procesar una cita de PERÚ.
 * Guarda en RDS y publica un evento de confirmación.
 */
export class ProcessAppointmentPEUseCase {
  constructor(
    private readonly countryRepository: IAppointmentCountryRepository,
    private readonly confirmationPublisher: IConfirmationPublisher
  ) {}

  /**
   * Ejecuta el caso de uso para Perú.
   * @param appointmentEvent El DTO del evento recibido de SNS.
   */
  async execute(appointmentEvent: SnsAppointmentEventDto): Promise<void> {
    const appointmentToSave: Appointment = {
      ...appointmentEvent,
      status: 'PENDING',
      updatedAt: new Date(appointmentEvent.createdAt).toISOString(),
    };

    // Aquí iría la futura lógica de negocio específica para Perú.
    console.log(`Executing Peru-specific appointment processing for ID: ${appointmentEvent.appointmentId}`);

    await this.countryRepository.save(appointmentToSave);

    await this.confirmationPublisher.publish({
      appointmentId: appointmentToSave.appointmentId,
      insuredId: appointmentToSave.insuredId,
      status: 'PROCESSED',
    });
  }
}// UpdateAppointmentStatus.ts
import { AppointmentEntity } from '../../domain/entities/Appointment';
import { IAppointmentRepository } from '../../domain/ports/repositories/IAppointmentRepository';
import { AppError, ErrorCode, HttpStatusCode } from '../../common/errors/AppError';

interface UpdateAppointmentStatusDto {
  appointmentId: string;
  insuredId: string;
}

/**
 * @description Caso de uso para actualizar el estado de una cita a 'COMPLETED'.
 */
export class UpdateAppointmentStatusUseCase {
  constructor(
    private readonly appointmentRepository: IAppointmentRepository
  ) {}

  /**
   * Ejecuta el caso de uso.
   * @param dto El DTO con los identificadores de la cita.
   */
  async execute(dto: UpdateAppointmentStatusDto): Promise<void> {
    const { appointmentId, insuredId } = dto;

    // 1. Encontrar la cita existente
    const existingAppointment = await this.appointmentRepository.findById({ appointmentId, insuredId });

    if (!existingAppointment) {
      // En un sistema real, podríamos mover este mensaje a una DLQ o registrar una alerta.
      // Por ahora, lanzamos un error para indicar que la cita no fue encontrada.
      throw new AppError(
        `Appointment with ID ${appointmentId} not found.`,
        ErrorCode.NotFound,
        HttpStatusCode.NOT_FOUND
      );
    }
    
    // 2. Rehidratar la entidad de dominio
    const appointmentEntity = new AppointmentEntity(existingAppointment);

    // 3. Ejecutar la lógica de dominio para completar la cita
    appointmentEntity.complete();

    // 4. Persistir los cambios usando el repositorio
    await this.appointmentRepository.update(appointmentEntity.values);
    
    console.log(`Appointment ${appointmentId} status updated to COMPLETED.`);
  }
}

// ===== Directory: packages/core/src/common/errors =====

// AppError.ts
// (Reutilizar el código de AppError y sus subclases del proyecto anterior)
export enum ErrorCode {
  BadRequest = "BAD_REQUEST",
  NotFound = "NOT_FOUND",
  ServerError = "SERVER_ERROR",
}

export enum HttpStatusCode {
  BAD_REQUEST = 400,
  NOT_FOUND = 404,
  INTERNAL_SERVER_ERROR = 500,
}

export class AppError extends Error {
  constructor(
    message: string,
    public errorCode: ErrorCode,
    public statusCode: HttpStatusCode,
    public errors?: object[]
  ) {
    super(message);
  }
}

export class BadRequestError extends AppError {
  constructor(errors?: object[], message?: string) {
    super(
      message ?? "La solicitud contiene datos inválidos.",
      ErrorCode.BadRequest,
      HttpStatusCode.BAD_REQUEST,
      errors
    );
  }
}

export class NotFoundError extends AppError {
  constructor(message: string = "Recurso no encontrado") {
    super(message, ErrorCode.NotFound, HttpStatusCode.NOT_FOUND);
  }
}


// ===== Directory: packages/core/src/common/utils =====

// validation.ts
import { z, ZodError } from 'zod/v4';
import { BadRequestError } from '../errors/AppError';

/**
 * Valida y parsea un objeto de datos usando un esquema de Zod v4.
 * Si la validación falla, lanza un AppError estandarizado con los detalles.
 *
 * @template T El tipo inferido del esquema.
 * @param {z.ZodSchema<T>} schema El esquema de Zod para la validación.
 * @param {unknown} data Los datos a validar.
 * @returns {T} Los datos validados y tipados.
 * @throws {AppError} Si la validación falla.
 */
export function validateAndParse<T>(schema: z.ZodSchema<T>, data: unknown): T {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof ZodError) {
      // Lanza nuestro error personalizado adjuntando los detalles de Zod.
      throw new BadRequestError(error.issues);
    }
    // Si es otro tipo de error, lo relanzamos.
    throw error;
  }
}

// ===== Directory: packages/core/src/domain/entities =====

// Appointment.ts
import { AppointmentSchema } from "@core/application/dtos/AppointmentDtos";
import { z } from "zod/v4";

export type Appointment = z.infer<typeof AppointmentSchema>;

export class AppointmentEntity {
  private props: Appointment;

  constructor(props: Appointment) {
    // Validamos los props al construir la entidad
    this.props = AppointmentSchema.parse(props);
  }

  static create(props: Omit<Appointment, 'appointmentId' | 'status' | 'createdAt' | 'updatedAt'>): AppointmentEntity {
    const now = new Date().toISOString();
    const appointmentData: Appointment = {
      ...props,
      appointmentId: crypto.randomUUID(),
      status: 'PENDING',
      createdAt: now,
      updatedAt: now,
    };
    
    return new AppointmentEntity(appointmentData);
  }

  get values(): Appointment {
    return { ...this.props };
  }

  complete(): void {
    if (this.props.status !== 'PENDING') {
      // Aquí podrías lanzar un DomainError si fuera necesario
      return;
    }
    this.props.status = 'COMPLETED';
    this.props.updatedAt = new Date().toISOString();
  }
}

// ===== Directory: packages/core/src/domain/ports =====

// IConfirmationPublisher.ts
/**
 * @description Interfaz para un publicador de eventos de confirmación de procesamiento.
 */
export interface IConfirmationPublisher {
  /**
   * Publica un evento de confirmación.
   * @param eventDetail El payload del evento.
   */
  publish(eventDetail: Record<string, any>): Promise<void>;
}// IEventPublisher.ts
export interface IEventPublisher {
  publish(topic: string, event: Record<string, any>, attributes?: Record<string, any>): Promise<void>;
}

// ===== Directory: packages/core/src/domain/ports/repositories =====

// IAppointmentCountryRepository.ts
import { Appointment } from "../../entities/Appointment";
export interface IAppointmentCountryRepository {
  save(appointment: Appointment): Promise<void>;
}// IAppointmentRepository.ts
import { Appointment } from "../../entities/Appointment";

export interface IAppointmentRepository {
  save(appointment: Appointment): Promise<void>;
  findById(keys: { appointmentId: string, insuredId: string }): Promise<Appointment | null>; // [!code ++]
  update(appointment: Appointment): Promise<void>; 
  findByInsuredId(insuredId: string): Promise<Appointment[]>;
}

// ===== Directory: packages/core =====

// tsconfig.json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*"]
}

// ===== Directory: packages/infrastructure =====

// package.json
{
  "name": "@infrastructure",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "dependencies": {
    "@aws-sdk/client-dynamodb": "^3.583.0",
    "@aws-sdk/client-eventbridge": "^3.873.0",
    "@aws-sdk/client-sns": "^3.583.0",
    "@aws-sdk/lib-dynamodb": "^3.873.0",
    "@aws-sdk/util-dynamodb": "^3.583.0",
    "awilix": "^10.0.1",
    "zod": "^4.0.17"
  },
  "devDependencies": {
    
  }
}

// ===== Directory: packages/infrastructure/src/common =====

// ErrorHandler.ts
import { AppError, ErrorCode, HttpStatusCode } from '@core/common/errors/AppError';

/**
 * Genera un log de error estructurado en formato JSON.
 * @param error El objeto de error capturado.
 */
function logError(error: Error | AppError): void {
  const logPayload = {
    level: "ERROR",
    timestamp: new Date().toISOString(),
    error: {
      name: error.name,
      message: error.message,
      stack: error.stack,
      ...((error instanceof AppError) && { // Agrega contexto si es un AppError
        code: error.errorCode,
        statusCode: error.statusCode,
        details: error.errors || [],
      }),
    }
  };
  console.error(JSON.stringify(logPayload, null, 2));
}

/**
 * Maneja los errores capturados en el Lambda y los convierte en una respuesta HTTP estándar.
 * También se encarga de registrar el error de forma estructurada.
 *
 * @param {unknown} error El error capturado.
 * @returns El objeto de respuesta HTTP para API Gateway.
 */
export function handleError(error: unknown) {
  if (error instanceof AppError) {
    logError(error);
    return {
      statusCode: error.statusCode,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        code: error.errorCode,
        message: error.message,
        ...(error.errors && { errors: error.errors }),
      }),
    };
  }

  // Captura de errores inesperados
  const unexpectedError = error instanceof Error
    ? error
    : new Error('An unexpected error occurred.');

  logError(unexpectedError);

  return {
    statusCode: HttpStatusCode.INTERNAL_SERVER_ERROR,
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      code: ErrorCode.ServerError,
      message: 'Ocurrió un error inesperado.',
    }),
  };
}// LambdaHandlerWrapper.ts
// packages/infrastructure/src/common/LambdaHandlerWrapper.ts

import { handleError } from './ErrorHandler';

/**
 * Wrapper para los manejadores de Lambda que abstrae el manejo de respuestas y errores.
 * Detecta si el evento proviene de API Gateway (HTTP) o SQS y formatea la
 * respuesta o maneja el error de la manera adecuada para cada servicio.
 */
export const lambdaHandlerWrapper = (handler: Function) => async (event: any, context: any) => {
  try {
    console.log('Request Event:', JSON.stringify(event, null, 2));
    const result = await handler(event, context);

    // Si el handler no retorna nada (típico en SQS), simplemente terminamos.
    if (result === undefined || result === null) {
      return;
    }

    // Si el resultado ya es una respuesta HTTP formateada, nos aseguramos
    // de que el body sea un string JSON antes de devolverlo.
    if (typeof result === 'object' && 'statusCode' in result && 'body' in result) {
      return {
        ...result,
        headers: {
          "Content-Type": "application/json",
          ...result.headers,
        },
        body: typeof result.body === 'string' ? result.body : JSON.stringify(result.body),
      };
    }

    // Si es un evento de API Gateway pero el handler solo devolvió el objeto del body,
    // lo envolvemos en una respuesta HTTP 200 estándar.
    if (event.requestContext) {
      return {
        statusCode: 200,
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(result),
      };
    }

    // Para cualquier otro tipo de invocación (ej. directa), retornamos el resultado tal cual.
    return result;
  } catch (error: unknown) {
    // Si el evento es de SQS, relanzamos el error para que SQS gestione los reintentos
    // y eventualmente lo mueva a la DLQ.
    if (event.Records && Array.isArray(event.Records)) {
      console.error('SQS Handler Error:', error);
      throw error;
    }
    
    // Para eventos HTTP, usamos nuestro manejador centralizado para devolver
    // una respuesta de error HTTP consistente.
    return handleError(error);
  }
};

// ===== Directory: packages/infrastructure/src/di =====

// container.ts
/**
 * @fileoverview Configuración del contenedor de inyección de dependencias (DI) para la aplicación.
 *
 * Este archivo utiliza la librería 'awilix' para registrar todas las implementaciones
 * concretas (adaptadores) de las interfaces definidas en el dominio (puertos).
 * Esto permite desacoplar la lógica de negocio de la infraestructura, facilitando
 * las pruebas y la mantenibilidad.
 */

import { createContainer, asClass, InjectionMode } from 'awilix';
import { CreateAppointmentUseCase } from '@core/application/use-cases/CreateAppointment';
import { ListAppointmentsUseCase } from '@core/application/use-cases/ListAppointments';
import { UpdateAppointmentStatusUseCase } from '@core/application/use-cases/UpdateAppointmentStatus';
import { GetAppointmentUseCase } from '@core/application/use-cases/GetAppointment'; // [!code ++]
// Importamos los nuevos casos de uso
import { ProcessAppointmentPEUseCase } from '@core/application/use-cases/ProcessAppointmentPE';
import { ProcessAppointmentCLUseCase } from '@core/application/use-cases/ProcessAppointmentCL';

// Se utilizan alias de ruta para consistencia
import { DynamoDbAppointmentRepository } from '@infrastructure/persistence/dynamodb/AppointmentRepository';
import { SnsEventPublisher } from '@infrastructure/messaging/SnsEventPublisher';
import { AppointmentRdsRepository } from '@infrastructure/persistence/rds/AppointmentRdsRepository';
import { EventBridgePublisher } from '@infrastructure/messaging/EventBridgePublisher';

const container = createContainer({
  injectionMode: InjectionMode.CLASSIC,
});

container.register({
  // Repositorios
  appointmentRepository: asClass(DynamoDbAppointmentRepository).singleton(),
  countryRepository: asClass(AppointmentRdsRepository).singleton(),
  
  // Publicadores de Eventos
  eventPublisher: asClass(SnsEventPublisher).singleton(),
  confirmationPublisher: asClass(EventBridgePublisher).singleton(),

  // Casos de Uso
  createAppointmentUseCase: asClass(CreateAppointmentUseCase).singleton(),
  listAppointmentsUseCase: asClass(ListAppointmentsUseCase).singleton(),
  getAppointmentUseCase: asClass(GetAppointmentUseCase).singleton(), // [!code ++]
  updateAppointmentStatusUseCase: asClass(UpdateAppointmentStatusUseCase).singleton(),
  
  // Registramos los nuevos casos de uso específicos y eliminamos el genérico
  processAppointmentPEUseCase: asClass(ProcessAppointmentPEUseCase).singleton(),
  processAppointmentCLUseCase: asClass(ProcessAppointmentCLUseCase).singleton(),
});

export { container };

// ===== Directory: packages/infrastructure/src/messaging =====

// EventBridgePublisher.ts
import { EventBridgeClient, PutEventsCommand } from '@aws-sdk/client-eventbridge';
import { IConfirmationPublisher } from '@core/domain/ports/IConfirmationPublisher';

/**
 * @description Publicador de eventos que utiliza AWS EventBridge.
 */
export class EventBridgePublisher implements IConfirmationPublisher {
  private readonly eventBridgeClient: EventBridgeClient;
  private readonly eventBusName = process.env.EVENT_BUS_NAME!;
  private readonly eventSource = 'appointment.processor';
  private readonly eventDetailType = 'AppointmentProcessed';

  constructor() {
    this.eventBridgeClient = new EventBridgeClient({
      region: process.env.AWS_REGION || 'us-east-1',
    });
  }

  /**
   * Publica un evento de confirmación en el bus de EventBridge.
   * @param detail El payload del evento.
   */
  async publish(detail: Record<string, any>): Promise<void> {
    const command = new PutEventsCommand({
      Entries: [
        {
          Source: this.eventSource,
          DetailType: this.eventDetailType,
          Detail: JSON.stringify(detail),
          EventBusName: this.eventBusName,
        },
      ],
    });

    try {
      await this.eventBridgeClient.send(command);
      console.log(`Event published successfully to EventBridge bus: ${this.eventBusName}`);
    } catch (error) {
      console.error('Error publishing event to EventBridge:', error);
      throw error;
    }
  }
}// SnsEventPublisher.ts
import { SNSClient, PublishCommand, MessageAttributeValue } from '@aws-sdk/client-sns';
import { IEventPublisher } from '@core/domain/ports/IEventPublisher';

/**
 * @description Implementación de IEventPublisher que publica eventos en un tópico de AWS SNS.
 */
export class SnsEventPublisher implements IEventPublisher {
  private readonly snsClient: SNSClient;
  private readonly topicArn = process.env.SNS_TOPIC_APPOINTMENTS_ARN!;

  constructor() {
    this.snsClient = new SNSClient({
      region: process.env.AWS_REGION || 'us-east-1',
      endpoint: process.env.IS_OFFLINE ? 'http://localhost:4002' : undefined,
    });
  }

  /**
   * Publica un evento en el tópico SNS configurado.
   * @param topic El nombre lógico del tema (no se usa directamente, se usa el ARN de la variable de entorno).
   * @param event El objeto del evento a publicar.
   * @param attributes Atributos del mensaje para filtrado en SNS.
   */
  async publish(topic: string, event: Record<string, any>, attributes?: Record<string, MessageAttributeValue>): Promise<void> {
    const command = new PublishCommand({
      TopicArn: this.topicArn,
      Message: JSON.stringify(event),
      MessageAttributes: attributes,
    });

    try {
      await this.snsClient.send(command);
      console.log(`Event published successfully to SNS topic: ${this.topicArn}`);
    } catch (error) {
      console.error('Error publishing event to SNS:', error);
      // En un caso real, aquí se podría implementar una estrategia de reintentos o "dead-letter queue".
      throw error;
    }
  }
}

// ===== Directory: packages/infrastructure/src/persistence/dynamodb =====

// AppointmentRepository.ts
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand, QueryCommand, GetCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { Appointment } from '@core/domain/entities/Appointment';

export class DynamoDbAppointmentRepository implements IAppointmentRepository {
  private readonly docClient: DynamoDBDocumentClient;
  private readonly tableName = process.env.DYNAMODB_TABLE_APPOINTMENTS!;

  constructor() {
    const client = new DynamoDBClient({
      endpoint: process.env.IS_OFFLINE ? 'http://localhost:8000' : undefined,
    });
    this.docClient = DynamoDBDocumentClient.from(client);
  }

  async save(appointment: Appointment): Promise<void> {
    const command = new PutCommand({
      TableName: this.tableName,
      Item: appointment,
    });
    await this.docClient.send(command);
  }

  async findById(keys: { appointmentId: string; insuredId: string }): Promise<Appointment | null> {
    const command = new GetCommand({
      TableName: this.tableName,
      Key: {
        insuredId: keys.insuredId,
        appointmentId: keys.appointmentId,
      },
    });
    const { Item } = await this.docClient.send(command);
    return (Item as Appointment) || null;
  }

  async update(appointment: Appointment): Promise<void> {
    const command = new UpdateCommand({
      TableName: this.tableName,
      Key: {
        insuredId: appointment.insuredId,
        appointmentId: appointment.appointmentId,
      },
      UpdateExpression: 'set #status = :status, updatedAt = :updatedAt',
      ExpressionAttributeNames: {
        '#status': 'status', // 'status' es una palabra reservada en DynamoDB
      },
      ExpressionAttributeValues: {
        ':status': appointment.status,
        ':updatedAt': appointment.updatedAt,
      },
    });
    await this.docClient.send(command);
  }
  
  async findByInsuredId(insuredId: string): Promise<Appointment[]> {
    const command = new QueryCommand({
      TableName: this.tableName,
      KeyConditionExpression: 'insuredId = :insuredId',
      ExpressionAttributeValues: {
        ':insuredId': insuredId,
      },
    });

    const { Items } = await this.docClient.send(command);
    return (Items as Appointment[]) || [];
  }
}

// ===== Directory: packages/infrastructure/src/persistence/rds =====

// AppointmentRdsRepository.ts
import { Appointment } from '@core/domain/entities/Appointment';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';

/**
 * @description Repositorio para manejar la persistencia de citas en una base de datos RDS (MySQL).
 * Asume una tabla `appointments` con la siguiente estructura (o similar):
 * CREATE TABLE appointments (
 * appointment_id VARCHAR(36) PRIMARY KEY,
 * insured_id VARCHAR(5) NOT NULL,
 * schedule_id INT NOT NULL,
 * country_iso VARCHAR(2) NOT NULL,
 * status VARCHAR(10) NOT NULL,
 * created_at TIMESTAMP NOT NULL
 * );
 */
export class AppointmentRdsRepository implements IAppointmentCountryRepository {

  constructor() {
    
  }

  /**
   * Guarda una cita en la base de datos MySQL.
   * @param appointment El objeto de la cita a persistir.
   */
  async save(appointment: Appointment): Promise<void> {
    const sql = `
      INSERT INTO appointments (appointment_id, insured_id, schedule_id, country_iso, status, created_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `;
    try {
     
      console.log(`Appointment SQL: ${sql}`);
      console.log(`Appointment ${appointment.appointmentId} saved to RDS.`);
    } catch (error) {
      console.error('Error saving appointment to RDS:', error);
      throw new Error('Failed to save appointment to RDS.');
    }
  }
}

// ===== Directory: packages/test/core/application/use-cases =====

// CreateAppointment.test.ts
import { CreateAppointmentUseCase } from '@core/application/use-cases/CreateAppointment';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { IEventPublisher } from '@core/domain/ports/IEventPublisher';
import { CreateAppointmentDto } from '@core/application/dtos/AppointmentDtos';

// Mockear crypto.randomUUID para tener un ID predecible en las pruebas
const MOCK_APPOINTMENT_ID = 'e7a4b0c4-9a2d-4f1e-8c6c-5e4a3b2a1f0e';
global.crypto = {
  ...global.crypto,
  randomUUID: () => MOCK_APPOINTMENT_ID,
};

describe('CreateAppointmentUseCase', () => {
  let appointmentRepository: jest.Mocked<IAppointmentRepository>;
  let eventPublisher: jest.Mocked<IEventPublisher>;
  let createAppointmentUseCase: CreateAppointmentUseCase;

  beforeEach(() => {
    appointmentRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      findByInsuredId: jest.fn(),
    };

    eventPublisher = {
      publish: jest.fn(),
    };

    createAppointmentUseCase = new CreateAppointmentUseCase(
      appointmentRepository,
      eventPublisher,
    );
  });

  it('debe crear una cita, guardarla en el repositorio y publicar un evento', async () => {
    // Arrange
    const dto: CreateAppointmentDto = {
      insuredId: '54321',
      scheduleId: 200,
      countryISO: 'CL',
    };

    // Act
    const result = await createAppointmentUseCase.execute(dto);

    // Assert
    expect(appointmentRepository.save).toHaveBeenCalledTimes(1);
    const savedAppointment = appointmentRepository.save.mock.calls[0][0];
    expect(savedAppointment).toMatchObject({
      appointmentId: MOCK_APPOINTMENT_ID,
      insuredId: '54321',
      scheduleId: 200,
      countryISO: 'CL',
      status: 'PENDING',
      createdAt: expect.any(String),
      updatedAt: expect.any(String),
    });

    expect(eventPublisher.publish).toHaveBeenCalledTimes(1);
    const [topic, eventPayload, attributes] = eventPublisher.publish.mock.calls[0];
    expect(topic).toBe('AppointmentRequested');
    expect(eventPayload).toMatchObject({
      appointmentId: MOCK_APPOINTMENT_ID,
      insuredId: '54321',
      scheduleId: 200,
      countryISO: 'CL',
      createdAt: savedAppointment.createdAt,
    });
    expect(attributes).toEqual({
      countryISO: {
        DataType: 'String',
        StringValue: 'CL',
      },
    });

    expect(result).toEqual(savedAppointment);
  });
});// GetAppointment.test.ts
// packages/test/core/application/use-cases/GetAppointment.test.ts

import { GetAppointmentUseCase } from '@core/application/use-cases/GetAppointment';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { Appointment } from '@core/domain/entities/Appointment';
import { NotFoundError } from '@core/common/errors/AppError';

describe('GetAppointmentUseCase', () => {
  let appointmentRepository: jest.Mocked<IAppointmentRepository>;
  let getAppointmentUseCase: GetAppointmentUseCase;

  beforeEach(() => {
    appointmentRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      findByInsuredId: jest.fn(),
    };
    getAppointmentUseCase = new GetAppointmentUseCase(appointmentRepository);
  });

  it('debe devolver los datos de una cita si se encuentra', async () => {
    // Arrange
    const dto = { insuredId: '12345', appointmentId: 'uuid-1' };
    const mockAppointment: Appointment = {
      ...dto,
      scheduleId: 101,
      countryISO: 'PE',
      status: 'PENDING',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    appointmentRepository.findById.mockResolvedValue(mockAppointment);

    // Act
    const result = await getAppointmentUseCase.execute(dto);

    // Assert
    expect(appointmentRepository.findById).toHaveBeenCalledWith(dto);
    expect(result).toEqual(mockAppointment);
  });

  it('debe lanzar un NotFoundError si la cita no se encuentra', async () => {
    // Arrange
    const dto = { insuredId: '12345', appointmentId: 'uuid-not-found' };
    appointmentRepository.findById.mockResolvedValue(null);

    // Act & Assert
    await expect(getAppointmentUseCase.execute(dto)).rejects.toThrow(NotFoundError);
    await expect(getAppointmentUseCase.execute(dto)).rejects.toThrow(
      `No se encontró la cita con ID ${dto.appointmentId}.`
    );
  });
});// ListAppointments.test.ts
import { ListAppointmentsUseCase } from '@core/application/use-cases/ListAppointments';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { Appointment } from '@core/domain/entities/Appointment';

describe('ListAppointmentsUseCase', () => {
  let appointmentRepository: jest.Mocked<IAppointmentRepository>;
  let listAppointmentsUseCase: ListAppointmentsUseCase;

  beforeEach(() => {
    appointmentRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      findByInsuredId: jest.fn(),
    };
    listAppointmentsUseCase = new ListAppointmentsUseCase(appointmentRepository);
  });

  it('debe devolver una lista de citas para un asegurado existente', async () => {
    // Arrange
    const insuredId = '11223';
    const mockAppointments: Appointment[] = [
      {
        appointmentId: 'uuid-1',
        insuredId,
        scheduleId: 1,
        countryISO: 'PE',
        status: 'PENDING',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      },
      {
        appointmentId: 'uuid-2',
        insuredId,
        scheduleId: 2,
        countryISO: 'PE',
        status: 'COMPLETED',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      },
    ];
    appointmentRepository.findByInsuredId.mockResolvedValue(mockAppointments);

    // Act
    const result = await listAppointmentsUseCase.execute(insuredId);

    // Assert
    expect(appointmentRepository.findByInsuredId).toHaveBeenCalledWith(insuredId);
    expect(result).toHaveLength(2);
    expect(result).toEqual(mockAppointments);
  });

  it('debe devolver un arreglo vacío si el asegurado no tiene citas', async () => {
    // Arrange
    const insuredId = '33445';
    appointmentRepository.findByInsuredId.mockResolvedValue([]);

    // Act
    const result = await listAppointmentsUseCase.execute(insuredId);

    // Assert
    expect(appointmentRepository.findByInsuredId).toHaveBeenCalledWith(insuredId);
    expect(result).toHaveLength(0);
    expect(result).toEqual([]);
  });
});// ProcessAppointmentCL.test.ts
import { ProcessAppointmentCLUseCase } from '@core/application/use-cases/ProcessAppointmentCL';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';
import { IConfirmationPublisher } from '@core/domain/ports/IConfirmationPublisher';
import { SnsAppointmentEventDto } from '@core/application/dtos/AppointmentDtos';

describe('ProcessAppointmentCLUseCase', () => {
  let rdsRepository: jest.Mocked<IAppointmentCountryRepository>;
  let confirmationPublisher: jest.Mocked<IConfirmationPublisher>;
  let useCase: ProcessAppointmentCLUseCase;

  beforeEach(() => {
    rdsRepository = { save: jest.fn() };
    confirmationPublisher = { publish: jest.fn() };
    useCase = new ProcessAppointmentCLUseCase(rdsRepository, confirmationPublisher);
  });

  it('debe guardar la cita en RDS y publicar un evento de confirmación', async () => {
    // Arrange
    const eventDto: SnsAppointmentEventDto = {
      appointmentId: 'uuid-cl-1',
      insuredId: '55555',
      scheduleId: 400,
      countryISO: 'CL',
      createdAt: new Date().toISOString(),
    };

    // Act
    await useCase.execute(eventDto);

    // Assert
    expect(rdsRepository.save).toHaveBeenCalledTimes(1);
    const savedAppointment = rdsRepository.save.mock.calls[0][0];
    expect(savedAppointment).toMatchObject({
      ...eventDto,
      status: 'PENDING',
      updatedAt: eventDto.createdAt,
    });

    expect(confirmationPublisher.publish).toHaveBeenCalledTimes(1);
    const publishedEvent = confirmationPublisher.publish.mock.calls[0][0];
    expect(publishedEvent).toEqual({
      appointmentId: eventDto.appointmentId,
      insuredId: eventDto.insuredId,
      status: 'PROCESSED',
    });
  });
});// ProcessAppointmentPE.test.ts
import { ProcessAppointmentPEUseCase } from '@core/application/use-cases/ProcessAppointmentPE';
import { IAppointmentCountryRepository } from '@core/domain/ports/repositories/IAppointmentCountryRepository';
import { IConfirmationPublisher } from '@core/domain/ports/IConfirmationPublisher';
import { SnsAppointmentEventDto } from '@core/application/dtos/AppointmentDtos';

describe('ProcessAppointmentPEUseCase', () => {
  let rdsRepository: jest.Mocked<IAppointmentCountryRepository>;
  let confirmationPublisher: jest.Mocked<IConfirmationPublisher>;
  let useCase: ProcessAppointmentPEUseCase;

  beforeEach(() => {
    rdsRepository = { save: jest.fn() };
    confirmationPublisher = { publish: jest.fn() };
    useCase = new ProcessAppointmentPEUseCase(rdsRepository, confirmationPublisher);
  });

  it('debe guardar la cita en RDS y publicar un evento de confirmación', async () => {
    // Arrange
    const eventDto: SnsAppointmentEventDto = {
      appointmentId: 'uuid-pe-1',
      insuredId: '98765',
      scheduleId: 300,
      countryISO: 'PE',
      createdAt: new Date().toISOString(),
    };

    // Act
    await useCase.execute(eventDto);

    // Assert
    expect(rdsRepository.save).toHaveBeenCalledTimes(1);
    const savedAppointment = rdsRepository.save.mock.calls[0][0];
    expect(savedAppointment).toMatchObject({
      ...eventDto,
      status: 'PENDING',
      updatedAt: eventDto.createdAt,
    });

    expect(confirmationPublisher.publish).toHaveBeenCalledTimes(1);
    const publishedEvent = confirmationPublisher.publish.mock.calls[0][0];
    expect(publishedEvent).toEqual({
      appointmentId: eventDto.appointmentId,
      insuredId: eventDto.insuredId,
      status: 'PROCESSED',
    });
  });
});// UpdateAppointmentStatus.test.ts
import { UpdateAppointmentStatusUseCase } from '@core/application/use-cases/UpdateAppointmentStatus';
import { IAppointmentRepository } from '@core/domain/ports/repositories/IAppointmentRepository';
import { Appointment } from '@core/domain/entities/Appointment';
import { AppError, ErrorCode } from '@core/common/errors/AppError';

describe('UpdateAppointmentStatusUseCase', () => {
  let appointmentRepository: jest.Mocked<IAppointmentRepository>;
  let useCase: UpdateAppointmentStatusUseCase;

  beforeEach(() => {
    appointmentRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      update: jest.fn(),
      findByInsuredId: jest.fn(),
    };
    useCase = new UpdateAppointmentStatusUseCase(appointmentRepository);
  });

  it('debe actualizar el estado de una cita a COMPLETED', async () => {
    // Arrange
    const dto = { appointmentId: 'uuid-1', insuredId: '12345' };
    const existingAppointment: Appointment = {
      ...dto,
      scheduleId: 1,
      countryISO: 'PE',
      status: 'PENDING',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    appointmentRepository.findById.mockResolvedValue(existingAppointment);

    // Act
    await useCase.execute(dto);

    // Assert
    expect(appointmentRepository.findById).toHaveBeenCalledWith(dto);
    expect(appointmentRepository.update).toHaveBeenCalledTimes(1);
    const updatedAppointment = appointmentRepository.update.mock.calls[0][0];
    expect(updatedAppointment.status).toBe('COMPLETED');
    expect(new Date(updatedAppointment.updatedAt).getTime()).toBeGreaterThan(new Date(existingAppointment.updatedAt).getTime());
  });

  it('debe lanzar un AppError si la cita no se encuentra', async () => {
    // Arrange
    const dto = { appointmentId: 'uuid-not-found', insuredId: '12345' };
    appointmentRepository.findById.mockResolvedValue(null);

    // Act & Assert
    await expect(useCase.execute(dto)).rejects.toThrow(
      new AppError(
        `Appointment with ID ${dto.appointmentId} not found.`,
        ErrorCode.NotFound,
        404
      )
    );
  });
});

// ===== Directory: packages/test/core/common/utils =====

// validation.test.ts
import { z, ZodError } from 'zod/v4';
import { validateAndParse } from '@core/common/utils/validation';
import { AppError, ErrorCode, HttpStatusCode } from '@core/common/errors/AppError';

// 1. Definimos un esquema simple para usar en las pruebas
const testSchema = z.object({
  name: z.string().min(3),
  age: z.number().positive(),
});

describe('validateAndParse', () => {

  // Test Case 1: El camino feliz, cuando los datos son válidos
  it('debe devolver los datos parseados cuando la validación es exitosa', () => {
    // Arrange
    const validData = { name: 'John Doe', age: 30 };

    // Act
    const result = validateAndParse(testSchema, validData);

    // Assert
    expect(result).toEqual(validData);
  });

  // Test Case 2: Cuando los datos no cumplen con el esquema de Zod
  it('debe lanzar un AppError estandarizado cuando la validación de Zod falla', () => {
    // Arrange
    const invalidData = { name: 'Jo', age: -5 }; // Nombre muy corto y edad negativa

    // Act & Assert
    try {
      validateAndParse(testSchema, invalidData);
      // Si llegamos aquí, la prueba falló porque no se lanzó un error
      fail('La función no lanzó ningún error');
    } catch (error) {
      expect(error).toBeInstanceOf(AppError);
      
      const appError = error as AppError;
      expect(appError.message).toBe('La solicitud contiene datos inválidos.');
      expect(appError.errorCode).toBe(ErrorCode.BadRequest);
      expect(appError.statusCode).toBe(HttpStatusCode.BAD_REQUEST);
      
      // Verificamos que los detalles del error de Zod se adjuntaron
      expect(appError.errors).toBeDefined();
      expect(Array.isArray(appError.errors)).toBe(true);
      expect(appError.errors?.length).toBe(2); // Esperamos dos errores de validación
    }
  });

  // Test Case 3: Cuando ocurre un error que no es de Zod
  it('debe relanzar el error si no es una instancia de ZodError', () => {
    // Arrange
    const unexpectedError = new Error('Error inesperado en la base de datos');
    
    // Creamos un esquema simulado que siempre lanza un error genérico
    const mockSchemaWithError = {
      parse: () => {
        throw unexpectedError;
      },
    } as any;

    // Act & Assert
    expect(() => {
      validateAndParse(mockSchemaWithError, {});
    }).toThrow(unexpectedError);
  });
});

// ===== Directory: . =====

// pnpm-workspace.yaml
# pnpm-workspace.yaml
packages:
  # Todos los paquetes en la carpeta 'packages'
  - 'packages/*'
  # Todos los servicios en la carpeta 'services'
  - 'services/*'// README.md
# Proyecto de Prueba para Agendamiento de Citas Médicas

Este repositorio contiene un proyecto de prueba que implementa un sistema de agendamiento de citas médicas utilizando una arquitectura serverless en AWS. El sistema está diseñado como un monorepo para facilitar la evaluación y demostración de habilidades técnicas.

## Resumen de Funcionalidades

El proyecto ofrece las siguientes capacidades principales:

1.  **Creación de Citas**: Expone un endpoint API (`POST /appointments`) para que los usuarios puedan solicitar una nueva cita médica.
2.  **Listado de Citas**: Proporciona un endpoint (`GET /appointments/{insuredId}`) para consultar todas las citas asociadas a un ID de asegurado.
3.  **Procesamiento Asíncrono por País**: Al crear una cita, se publica un evento en un tópico de SNS. Este evento es filtrado y encolado en colas SQS específicas según el país (`PE` para Perú, `CL` para Chile).
4.  **Procesadores de Citas**: Lambdas especializadas (`processPE` y `processCL`) consumen los mensajes de sus respectivas colas SQS para procesar la cita.
5.  **Actualización de Estado**: Una vez que una cita es procesada, se emite un evento a EventBridge, que a su vez encola un mensaje en una cola SQS de "completados". Un handler en la API principal consume este mensaje para actualizar el estado de la cita en la base de datos.

## Guía de Uso y Despliegue

### Prerrequisitos

-   Node.js (v20.x o superior)
-   PNPM (manejador de paquetes)
-   Serverless Framework (`npm install -g serverless`)
-   AWS CLI con credenciales configuradas en su entorno.

### Instalación Local

Clone el repositorio y ejecute el siguiente comando para instalar todas las dependencias del monorepo:

```bash
pnpm install
```

### Ejecución de Pruebas

Para correr las pruebas unitarias y de integración definidas en el proyecto, utilice:

```bash
pnpm test
```

### Modo Offline (Desarrollo Local)

Puede simular el entorno de AWS (API Gateway, Lambda, DynamoDB) en su máquina local. Para iniciar el servicio de API en modo offline, ejecute:

```bash
pnpm run offline:api
```

Esto levantará un servidor local. Los endpoints de la API estarán disponibles en `http://localhost:3000`.

### Gestión de la Documentación (OpenAPI)

El proyecto incluye un script para generar una especificación OpenAPI (`openapi.yaml`) a partir del lo que esté definido en el archivo ./scripts/generate-openapi.ts.

-   **Para generar el archivo `openapi.yaml`**, ejecute:
    ```bash
    pnpm run docs:generate
    ```

### Acceso a la Documentación

Una vez que la API está desplegada, puedes acceder a la documentación interactiva y a la especificación OpenAPI a través de los siguientes endpoints:

-   **Swagger UI (Interfaz Interactiva)**: `https://<URL_BASE_DE_LA_API>/docs`
-   **Especificación OpenAPI (YAML)**: `https://<URL_BASE_DE_LA_API>/openapi.yaml`

Sustituye `<URL_BASE_DE_LA_API>` por la URL que recibiste por correo.

### Endpoints Disponibles

A continuación se detallan las rutas disponibles en la API:

| Método | Ruta                                                                      |
|--------|---------------------------------------------------------------------------|
| POST   | `http://localhost:3000/appointments`                                      |
| POST   | `http://localhost:3000/2015-03-31/functions/appointmentHandler/invocations` |
| GET    | `http://localhost:3000/appointments/{insuredId}`                          |
| POST   | `http://localhost:3000/2015-03-31/functions/appointmentHandler/invocations` |
| GET    | `http://localhost:3000/appointments/{insuredId}/{appointmentId}`          |
| POST   | `http://localhost:3000/2015-03-31/functions/appointmentHandler/invocations` |
| GET    | `http://localhost:3000/docs`                                              |
| POST   | `http://localhost:3000/2015-03-31/functions/swagger/invocations`          |
| GET    | `http://localhost:3000/docs/{proxy*}`                                     |
| POST   | `http://localhost:3000/2015-03-31/functions/swagger/invocations`          |
| GET    | `http://localhost:3000/openapi.yaml`                                      |


### Despliegue en AWS

El proyecto se compone de dos servicios que deben desplegarse de forma independiente.

1.  **Desplegar la API de Citas**:
    ```bash
    pnpm run deploy:api
    ```

2.  **Desplegar los Procesadores de Citas**:
    ```bash
    pnpm run deploy:processor
    ```

Estos comandos utilizarán las credenciales de AWS configuradas en su entorno para provisionar toda la infraestructura necesaria a través de CloudFormation.

## Pruebas de Endpoints con cURL

Para verificar que la API desplegada funciona correctamente, puedes utilizar el script `scripts/test-api.sh`. Este script realiza una serie de peticiones cURL a los endpoints principales.

**Uso:**

```bash
./scripts/test-api.sh <URL_BASE_DE_LA_API>
```

**Importante:** La `<URL_BASE_DE_LA_API>` es la URL raíz de la API desplegada en AWS. Esta URL te será enviada por correo electrónico una vez que la infraestructura esté lista.

## Estructura del Proyecto (Monorepo)

El código está organizado en los siguientes paquetes y servicios:

-   `packages/`: Contiene la lógica de negocio y las implementaciones de infraestructura, separadas de los servicios desplegables.
    -   `core/`: Representa el corazón de la aplicación. Define las entidades de dominio (ej. `Appointment`), los casos de uso (ej. `CreateAppointment`), y los puertos (interfaces) para las dependencias externas como repositorios y publicadores de eventos. Es agnóstico a la tecnología.
    -   `infrastructure/`: Implementa los puertos definidos en `core`. Contiene la lógica para interactuar con servicios externos, como el repositorio de `DynamoDB` y los publicadores de eventos para `SNS` y `EventBridge`.

-   `services/`: Contiene los microservicios desplegables utilizando el Serverless Framework.
    -   `appointment-api/`: El servicio principal que expone la API REST pública a través de AWS API Gateway y AWS Lambda. Gestiona la creación, el listado y la actualización de estado de las citas.
    -   `appointment-processor/`: Contiene los workers asíncronos (Lambdas) que se encargan de procesar las citas recibidas desde las colas SQS.

## Infraestructura

La solución está construida sobre los siguientes servicios de AWS, orquestados a través del **Serverless Framework**:

-   **AWS Lambda**: Para la ejecución del código de la API y los procesadores de eventos.
-   **Amazon API Gateway**: Para exponer los endpoints HTTP de la API de citas.
-   **Amazon DynamoDB**: Como base de datos NoSQL para persistir la información de las citas.
-   **Amazon SNS (Simple Notification Service)**: Para la publicación de eventos de creación de citas y la distribución (fan-out) a múltiples suscriptores.
-   **Amazon SQS (Simple Queue Service)**: Para el encolamiento de mensajes, desacoplando la creación de la cita de su procesamiento y garantizando la entrega.
-   **Amazon EventBridge**: Para un bus de eventos más avanzado que gestiona la comunicación entre los procesadores y el servicio de API para la actualización de estado.

## Consideraciones Importantes

Es fundamental tener en cuenta los siguientes puntos al evaluar este proyecto:

> - **Esquema de Monorepo**: Este proyecto se ha estructurado como un monorepo para facilitar la prueba y la evaluación en un único repositorio. En un entorno de producción con un equipo de desarrollo más grande, es probable que los servicios (`appointment-api`, `appointment-processor`) y los paquetes (`core`, `infrastructure`) residan en repositorios separados para mejorar la autonomía de los equipos y la independencia de los despliegues.
>
> - **Prueba de Concepto**: Se debe entender que este proyecto es una prueba diseñada para corroborar los conocimientos técnicos requeridos para un rol específico. **No debe tomarse como base para una implementación en producción**, ya que carece de varios componentes críticos.
>
> - **Omisiones Deliberadas**: Para mantener el enfoque en la lógica de negocio principal, se han omitido intencionadamente los siguientes aspectos:
>    - **Seguridad y Autenticación**: No hay mecanismos de autenticación de usuarios ni autorización de endpoints.
>    - **CI/CD**: No se ha implementado un pipeline de integración y despliegue continuo. Los despliegues se realizan manualmente a través de los comandos del Serverless Framework.
>    - **Monitoreo y Alarmas**: Carece de un sistema robusto de monitoreo de errores, observabilidad y alarmas proactivas.

// ===== Directory: services/appointment-api =====

// openapi.yaml
openapi: 3.1.0
info:
  title: API de Agendamiento de Citas Médicas
  version: 1.0.0
  description: API para gestionar la creación y consulta de citas médicas.
servers:
  - url: /dev
paths:
  /appointments:
    post:
      summary: Crear una nueva cita médica
      description: Registra una nueva cita y la envía para procesamiento asíncrono.
      tags:
        - Appointments
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/CreateAppointmentRequest"
      responses:
        "202":
          description: Cita aceptada para procesamiento.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/AppointmentResponse"
        "400":
          description: Datos de la solicitud inválidos.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
  /appointments/{insuredId}:
    get:
      summary: Listar citas por asegurado
      description: Obtiene todas las citas médicas registradas para un ID de asegurado
        específico.
      tags:
        - Appointments
      parameters:
        - name: insuredId
          in: path
          required: true
          schema: &a1
            type: string
            pattern: ^[0-9]{5}$
      responses:
        "200":
          description: Lista de citas obtenida exitosamente.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/AppointmentsListResponse"
        "400":
          description: El ID del asegurado es inválido.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
        "404":
          description: Asegurado no encontrado o sin citas.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
  /appointments/{insuredId}/{appointmentId}:
    get:
      summary: Obtener una cita específica
      description: Obtiene los detalles de una cita médica específica por su ID.
      tags:
        - Appointments
      parameters:
        - name: insuredId
          in: path
          required: true
          schema: &a2
            type: string
            pattern: ^[0-9]{5}$
        - name: appointmentId
          in: path
          required: true
          schema: &a3
            type: string
            format: uuid
            pattern: ^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$
      responses:
        "200":
          description: Detalles de la cita obtenidos exitosamente.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/AppointmentResponse"
        "400":
          description: Uno o más IDs son inválidos.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
        "404":
          description: La cita no fue encontrada.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ErrorResponse"
components:
  schemas:
    CreateAppointmentRequest:
      $schema: https://json-schema.org/draft/2020-12/schema
      type: object
      properties:
        insuredId:
          type: string
          pattern: ^[0-9]{5}$
        scheduleId:
          type: integer
          exclusiveMinimum: 0
          maximum: 9007199254740991
        countryISO:
          type: string
          enum:
            - PE
            - CL
      required:
        - insuredId
        - scheduleId
        - countryISO
      additionalProperties: false
    ListAppointmentsParams:
      $schema: https://json-schema.org/draft/2020-12/schema
      type: object
      properties:
        insuredId: *a1
      required:
        - insuredId
      additionalProperties: false
    GetAppointmentParams:
      $schema: https://json-schema.org/draft/2020-12/schema
      type: object
      properties:
        insuredId: *a2
        appointmentId: *a3
      required:
        - insuredId
        - appointmentId
      additionalProperties: false
    AppointmentResponse:
      $schema: https://json-schema.org/draft/2020-12/schema
      type: object
      properties:
        appointmentId:
          type: string
        insuredId:
          type: string
          minLength: 5
          maxLength: 5
        scheduleId:
          type: integer
          exclusiveMinimum: 0
          maximum: 9007199254740991
        countryISO:
          type: string
          enum:
            - PE
            - CL
        status:
          type: string
          enum:
            - PENDING
            - COMPLETED
            - FAILED
        createdAt:
          type: string
          format: date-time
          pattern: ^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$
        updatedAt:
          type: string
          format: date-time
          pattern: ^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$
      required:
        - appointmentId
        - insuredId
        - scheduleId
        - countryISO
        - status
        - createdAt
        - updatedAt
      additionalProperties: false
    AppointmentsListResponse:
      $schema: https://json-schema.org/draft/2020-12/schema
      type: array
      items:
        type: object
        properties:
          appointmentId:
            type: string
          insuredId:
            type: string
            minLength: 5
            maxLength: 5
          scheduleId:
            type: integer
            exclusiveMinimum: 0
            maximum: 9007199254740991
          countryISO:
            type: string
            enum:
              - PE
              - CL
          status:
            type: string
            enum:
              - PENDING
              - COMPLETED
              - FAILED
          createdAt:
            type: string
            format: date-time
            pattern: ^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$
          updatedAt:
            type: string
            format: date-time
            pattern: ^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$
        required:
          - appointmentId
          - insuredId
          - scheduleId
          - countryISO
          - status
          - createdAt
          - updatedAt
        additionalProperties: false
    ErrorResponse:
      $schema: https://json-schema.org/draft/2020-12/schema
      type: object
      properties:
        code:
          description: Código de error estandarizado (ej. BAD_REQUEST).
          type: string
        message:
          description: Mensaje legible que describe el error.
          type: string
        errors:
          description: Lista de errores de validación detallados (opcional).
          type: array
          items:
            type: object
            properties:
              code:
                type: string
              path:
                type: array
                items:
                  anyOf:
                    - type: string
                    - type: number
              message:
                type: string
            required:
              - code
              - path
              - message
            additionalProperties: false
      required:
        - code
        - message
      additionalProperties: false
// serverless.yml
# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: aivoxia
service: appointment-api

provider:
  name: aws
  runtime: nodejs20.x
  region: ${opt:region, 'us-east-2'}
  stage: ${opt:stage, 'dev'}
  # Añadimos tags que se aplicarán a todos los recursos de la stack
  tags:
    app-id: test-medical-appoinments
    app-center-cost: test-medical-appoinments
    app-env: test
  environment:
    DYNAMODB_TABLE_APPOINTMENTS: ${self:custom.tableName}
    SNS_TOPIC_APPOINTMENTS_ARN: { "Ref": "AppointmentsTopic" }

  iam:
    role:
      statements:
        # Permisos
        - Effect: "Allow"
          Action:
            - dynamodb:PutItem
            - dynamodb:GetItem
            - dynamodb:UpdateItem
            - dynamodb:Query
          Resource:
            - Fn::GetAtt: [AppointmentsTable, Arn]
            
        - Effect: "Allow"
          Action:
            - sns:Publish
          Resource:
            - Ref: AppointmentsTopic

plugins:
  - serverless-offline
  - serverless-dynamodb-local

package:
  individually: true
  patterns:
    - '!node_modules/**'
    - 'node_modules/swagger-ui-dist/**' # Incluir los assets de Swagger UI
    - 'openapi.yaml' # Incluir el archivo de especificación

custom:
  tableName: appointments-table-${self:provider.stage}
  dynamodb:
    start:
      port: 8000
      inMemory: true
      migrate: true

functions:
  appointmentHandler:
    handler: src/handlers/appointment.handler
    events:
      - httpApi:
          path: /appointments
          method: post
      - httpApi:
          path: /appointments/{insuredId}
          method: get
      - httpApi:
          path: /appointments/{insuredId}/{appointmentId}
          method: get
      - sqs:
          arn:
            Fn::GetAtt: [AppointmentsCompletionQueue, Arn]
  
  swagger:
    handler: src/handlers/swagger.ui
    events:
      - httpApi:
          path: /docs
          method: get
      - httpApi: # Ruta para los assets de Swagger UI
          path: /docs/{proxy+}
          method: get
  
  swaggerSpec:
    handler: src/handlers/swagger.spec
    events:
      - httpApi:
          path: /openapi.yaml
          method: get

resources:
  Resources:
    AppointmentsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tableName}
        AttributeDefinitions:
          - AttributeName: insuredId
            AttributeType: S
          - AttributeName: appointmentId
            AttributeType: S
        KeySchema:
          - AttributeName: insuredId
            KeyType: HASH
          - AttributeName: appointmentId
            KeyType: RANGE
        BillingMode: PAY_PER_REQUEST
    
    AppointmentsTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: appointments-topic-${self:provider.stage}

    AppointmentsQueuePE:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: appointments-queue-pe-${self:provider.stage}

    AppointmentsQueueCL:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: appointments-queue-cl-${self:provider.stage}

    SnsSubscriptionPE:
      Type: AWS::SNS::Subscription
      Properties:
        Protocol: sqs
        Endpoint: { "Fn::GetAtt": ["AppointmentsQueuePE", "Arn"] }
        TopicArn: { "Ref": "AppointmentsTopic" }
        FilterPolicy:
          countryISO: ["PE"]
        RawMessageDelivery: "true"

    SnsSubscriptionCL:
      Type: AWS::SNS::Subscription
      Properties:
        Protocol: sqs
        Endpoint: { "Fn::GetAtt": ["AppointmentsQueueCL", "Arn"] }
        TopicArn: { "Ref": "AppointmentsTopic" }
        FilterPolicy:
          countryISO: ["CL"]
        RawMessageDelivery: "true"

    SqsPolicy:
      Type: AWS::SQS::QueuePolicy
      Properties:
        Queues:
          - { "Ref": "AppointmentsQueuePE" }
          - { "Ref": "AppointmentsQueueCL" }
        PolicyDocument:
          Statement:
            - Effect: "Allow"
              Principal:
                Service: "sns.amazonaws.com"
              Action: "sqs:SendMessage"
              Resource: "*"
              Condition:
                ArnEquals:
                  aws:SourceArn: { "Ref": "AppointmentsTopic" }
    
    AppointmentEventBus:
      Type: AWS::Events::EventBus
      Properties:
        Name: appointment-event-bus-${self:provider.stage}
        
    AppointmentsCompletionQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: appointments-completion-queue-${self:provider.stage}
        
    EventBusToSqsRule:
      Type: AWS::Events::Rule
      Properties:
        EventBusName: { "Ref": "AppointmentEventBus" }
        EventPattern:
          source:
            - "appointment.processor"
        Targets:
          - Arn: { "Fn::GetAtt": ["AppointmentsCompletionQueue", "Arn"] }
            Id: "CompletionQueueTarget"
            
    EventBridgeToSqsPolicy:
      Type: AWS::SQS::QueuePolicy
      Properties:
        Queues:
          - Ref: AppointmentsCompletionQueue
        PolicyDocument:
          Statement:
            - Effect: Allow
              Principal:
                Service: events.amazonaws.com
              Action: sqs:SendMessage
              Resource: { "Fn::GetAtt": ["AppointmentsCompletionQueue", "Arn"] }

// ===== Directory: services/appointment-api/src/handlers =====

// appointment.ts
import { container } from '@infrastructure/di/container';
import { lambdaHandlerWrapper } from '@infrastructure/common/LambdaHandlerWrapper';
import { validateAndParse } from '@core/common/utils/validation';
import { AppError, ErrorCode, HttpStatusCode } from '@core/common/errors/AppError';
import type { CreateAppointmentUseCase } from '@core/application/use-cases/CreateAppointment';
import type { ListAppointmentsUseCase } from '@core/application/use-cases/ListAppointments';
import type { UpdateAppointmentStatusUseCase } from '@core/application/use-cases/UpdateAppointmentStatus';
import type { GetAppointmentUseCase } from '@core/application/use-cases/GetAppointment';

import { 
  CreateAppointmentSchema, 
  ListAppointmentsRequestSchema, 
  UpdateAppointmentStatusEventSchema,
  GetAppointmentRequestSchema 
} from '@core/application/dtos/AppointmentDtos';

// --- Controladores de Endpoints HTTP ---

/**
 * Maneja la creación de una nueva cita.
 * Corresponde a: POST /appointments
 */
async function createAppointmentHandler(event: any) {
  const body = JSON.parse(event.body);
  const dto = validateAndParse(CreateAppointmentSchema, body);
  const useCase = container.resolve<CreateAppointmentUseCase>('createAppointmentUseCase');
  const result = await useCase.execute(dto);
  return { statusCode: 202, body: result };
}

/**
 * Maneja la obtención de una cita específica por su ID.
 * Corresponde a: GET /appointments/{insuredId}/{appointmentId}
 */
async function getAppointmentHandler(event: any) {
  const dto = validateAndParse(GetAppointmentRequestSchema, event.pathParameters || {});
  const useCase = container.resolve<GetAppointmentUseCase>('getAppointmentUseCase');
  const result = await useCase.execute(dto);
  return { statusCode: 200, body: result };
}

/**
 * Maneja el listado de todas las citas de un asegurado.
 * Corresponde a: GET /appointments/{insuredId}
 */
async function listAppointmentsHandler(event: any) {
  const { insuredId } = validateAndParse(ListAppointmentsRequestSchema, event.pathParameters || {});
  const useCase = container.resolve<ListAppointmentsUseCase>('listAppointmentsUseCase');
  const result = await useCase.execute(insuredId);
  return { statusCode: 200, body: result };
}

// --- Routers por Origen de Evento ---

/**
 * Enruta las peticiones HTTP al controlador adecuado basado en el método y los parámetros.
 */
async function handleHttpRequest(event: any) {
  const method = event.requestContext.http.method;
  const pathParameters = event.pathParameters || {};

  if (method === 'POST') {
    return createAppointmentHandler(event);
  }

  if (method === 'GET') {
    // La ruta más específica (con appointmentId) se comprueba primero.
    if (pathParameters.appointmentId) {
      return getAppointmentHandler(event);
    }
    // La ruta general para listar.
    if (pathParameters.insuredId) {
      return listAppointmentsHandler(event);
    }
  }

  throw new AppError(`Ruta no encontrada: ${method} ${event.rawPath}`, ErrorCode.NotFound, HttpStatusCode.NOT_FOUND);
}

/**
 * Procesa los mensajes provenientes de la cola SQS para actualizar el estado de las citas.
 */
async function handleSqsRequest(event: any) {
  console.log('Processing SQS event for status update');
  const useCase = container.resolve<UpdateAppointmentStatusUseCase>('updateAppointmentStatusUseCase');

  for (const record of event.Records) {
    const body = JSON.parse(record.body);
    const eventDetail = body.detail;
    const validatedEvent = validateAndParse(UpdateAppointmentStatusEventSchema, eventDetail);
    await useCase.execute({
      appointmentId: validatedEvent.appointmentId,
      insuredId: validatedEvent.insuredId,
    });
  }
}

// --- Handler Principal (Punto de Entrada) ---

/**
 * @description Punto de entrada principal para la Lambda.
 * Delega el evento al router correspondiente según su origen (API Gateway o SQS).
 */
async function mainHandler(event: any) {
  if (event.requestContext?.http) {
    return handleHttpRequest(event);
  }

  if (event.Records && Array.isArray(event.Records)) {
    await handleSqsRequest(event);
    return; // Los manejadores de SQS no devuelven una respuesta HTTP.
  }
  
  throw new AppError('Tipo de evento no soportado', ErrorCode.BadRequest, HttpStatusCode.BAD_REQUEST);
}

export const handler = lambdaHandlerWrapper(mainHandler);// swagger.ts
import * as fs from 'fs';
import * as path from 'path';

// Cargar el archivo openapi.yaml una sola vez cuando el Lambda se inicie.
const yamlSpec = fs.readFileSync(path.join(__dirname, '../../openapi.yaml'), 'utf8');

/**
 * @description Sirve la interfaz de usuario de Swagger UI.
 * Genera un HTML que carga los assets (CSS, JS) desde una CDN pública.
 */
export const ui = async () => {
  const html = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>Swagger UI</title>
      <link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css" />
      <style>
        html { box-sizing: border-box; overflow: -moz-scrollbars-vertical; overflow-y: scroll; }
        *, *:before, *:after { box-sizing: inherit; }
        body { margin:0; background: #fafafa; }
      </style>
    </head>
    <body>
      <div id="swagger-ui"></div>
      <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js" charset="UTF-8"></script>
      <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-standalone-preset.js" charset="UTF-8"></script>
      <script>
        window.onload = function() {
          // Iniciar Swagger UI
          window.ui = SwaggerUIBundle({
            url: "/openapi.yaml", // URL donde se sirve la especificación
            dom_id: '#swagger-ui',
            deepLinking: true,
            presets: [
              SwaggerUIBundle.presets.apis,
              SwaggerUIStandalonePreset
            ],
            plugins: [
              SwaggerUIBundle.plugins.DownloadUrl
            ],
            layout: "StandaloneLayout"
          });
        };
      </script>
    </body>
    </html>
  `;

  return {
    statusCode: 200,
    headers: {
      'Content-Type': 'text/html',
    },
    body: html,
  };
};

/**
 * @description Sirve el archivo de especificación openapi.yaml directamente.
 * La interfaz de usuario de Swagger hará una petición a esta ruta para obtener la definición de la API.
 */
export const spec = async () => {
    return {
        statusCode: 200,
        headers: {
            'Content-Type': 'application/yaml',
        },
        body: yamlSpec,
    };
};


// ===== Directory: services/appointment-processor =====

// serverless.yml
service: appointment-processor

provider:
  name: aws
  runtime: nodejs20.x
  region: ${opt:region, 'us-east-2'}
  stage: ${opt:stage, 'dev'}
  profile: ${opt:profile, 'aivoxia'}
  # Añadimos tags que se aplicarán a todos los recursos de la stack
  tags:
    app-id: test-medical-appoinments
    app-center-cost: test-medical-appoinments
    app-env: test
  environment:
    EVENT_BUS_NAME: appointment-event-bus-${self:provider.stage}
    # Estas variables deben ser configuradas de forma segura (ej. SSM Parameter Store o .env)
    #RDS_HOST: ${env:RDS_HOST}
    #RDS_USER: ${env:RDS_USER}
    #RDS_PASSWORD: ${env:RDS_PASSWORD}
    #RDS_DATABASE: ${env:RDS_DATABASE}
  iam:
    role:
      statements:
        - Effect: "Allow"
          Action:
            - events:PutEvents
          Resource:
            - Fn::Join:
              - ''
              - - 'arn:aws:events:'
                - ${self:provider.region}
                - ':'
                - Ref: AWS::AccountId
                - ':event-bus/${self:provider.environment.EVENT_BUS_NAME}'
package:
  individually: true

functions:
  processPE:
    # Apuntamos al nuevo handler para Perú
    handler: src/handlers/processPE.handler
    events:
      - sqs:
          arn:
            Fn::Join:
              - ":"
              - - "arn:aws:sqs"
                - ${self:provider.region}
                - { Ref: "AWS::AccountId" }
                - "appointments-queue-pe-${self:provider.stage}"

  processCL:
    # Apuntamos al nuevo handler para Chile
    handler: src/handlers/processCL.handler
    events:
      - sqs:
          arn:
            Fn::Join:
              - ":"
              - - "arn:aws:sqs"
                - ${self:provider.region}
                - { Ref: "AWS::AccountId" }
                - "appointments-queue-cl-${self:provider.stage}"

# NOTA: En un proyecto real, se definirían aquí los permisos IAM explícitos
# para que los lambdas puedan acceder a SQS, RDS (VPC) y EventBridge.

// ===== Directory: services/appointment-processor/src/handlers =====

// processCL.ts
import { SnsAppointmentEventSchema } from '@core/application/dtos/AppointmentDtos';
import { ProcessAppointmentCLUseCase } from '@core/application/use-cases/ProcessAppointmentCL';
import { container } from '@infrastructure/di/container';
import { validateAndParse } from '@core/common/utils/validation';

import { lambdaHandlerWrapper } from '@infrastructure/common/LambdaHandlerWrapper';

async function processCLHandler(event: any): Promise<void> {
  console.log('Received SQS event for CL:', JSON.stringify(event, null, 2));

  const useCase = container.resolve<ProcessAppointmentCLUseCase>('processAppointmentCLUseCase');

  for (const record of event.Records) {
    const body = JSON.parse(record.body);
    const appointmentEvent = validateAndParse(SnsAppointmentEventSchema, body);
    await useCase.execute(appointmentEvent);
  }
}

export const handler = lambdaHandlerWrapper(processCLHandler);
// processPE.ts
import { SnsAppointmentEventSchema } from '@core/application/dtos/AppointmentDtos';
import { ProcessAppointmentPEUseCase } from '@core/application/use-cases/ProcessAppointmentPE';
import { container } from '@infrastructure/di/container';
import { validateAndParse } from '@core/common/utils/validation';
import { lambdaHandlerWrapper } from '@infrastructure/common/LambdaHandlerWrapper';

async function processPEHandler(event: any): Promise<void> {
  console.log('Received SQS event for PE:', JSON.stringify(event, null, 2));

  const useCase = container.resolve<ProcessAppointmentPEUseCase>('processAppointmentPEUseCase');

  for (const record of event.Records) {
    const body = JSON.parse(record.body);
    const appointmentEvent = validateAndParse(SnsAppointmentEventSchema, body);
    await useCase.execute(appointmentEvent);
  }
}

export const handler = lambdaHandlerWrapper(processPEHandler);



// ===== Directory: . =====

// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["es2022"],
    "declaration": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "composite": true,
    "baseUrl": ".",
    "paths": {
      "@core/*": ["packages/core/src/*"],
      "@infrastructure/*": ["packages/infrastructure/src/*"]
    }
  }
}